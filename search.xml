<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>牛的学术圈I</title>
      <link href="2022/03/17/niu-de-xue-zhu-quan-i/"/>
      <url>2022/03/17/niu-de-xue-zhu-quan-i/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p><a href="https://www.acwing.com/problem/content/3748/">3745. 牛的学术圈 I - AcWing题库</a></p><p>由于对计算机科学的热爱，以及有朝一日成为 「Bessie 博士」的诱惑，奶牛 Bessie 开始攻读计算机科学博士学位。</p><p>经过一段时间的学术研究，她已经发表了 $N$ 篇论文，并且她的第 $i$ 篇论文得到了来自其他研究文献的 $c_i$ 次引用。</p><p>Bessie 听说学术成就可以用 $h$ 指数来衡量。</p><p>$h$ 指数等于使得研究员有至少 $h$ 篇引用次数不少于 $h$ 的论文的最大整数 $h$。</p><p>例如，如果一名研究员有 $4$ 篇论文，引用次数分别为 $(1,100,2,3)$，则 $h$ 指数为 $2$，然而若引用次数为 $(1,100,3,3)$ 则 $h$ 指数将会是 $3$。</p><p>为了提升她的 $h$ 指数，Bessie 计划写一篇综述，并引用一些她曾经写过的论文。</p><p>由于页数限制，她至多可以在这篇综述中引用 $L$ 篇论文，并且她只能引用每篇她的论文至多一次。</p><p>请帮助 Bessie 求出在写完这篇综述后她可以达到的最大 $h$ 指数。</p><p>注意 Bessie 的导师可能会告知她纯粹为了提升 $h$ 指数而写综述存在违反学术道德的嫌疑；我们不建议其他学者模仿 Bessie 的行为。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入的第一行包含 $N$ 和 $L$。</p><p>第二行包含 $N$ 个空格分隔的整数 $c_1,…,c_N$。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出写完综述后 Bessie 可以达到的最大 hh 指数。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>$1≤N≤10^5$,<br>$0≤c_i≤10^5$,<br>$0≤L≤10^5$</p><h4 id="输入样例1："><a href="#输入样例1：" class="headerlink" title="输入样例1："></a>输入样例1：</h4><pre><code>4 01 100 2 3</code></pre><h4 id="输出样例1："><a href="#输出样例1：" class="headerlink" title="输出样例1："></a>输出样例1：</h4><pre><code>2</code></pre><h4 id="样例1解释"><a href="#样例1解释" class="headerlink" title="样例1解释"></a>样例1解释</h4><p>Bessie 不能引用任何她曾经写过的论文。上文中提到，$(1,100,2,3)$ 的 $h$ 指数为 $2$。</p><h4 id="输入样例2："><a href="#输入样例2：" class="headerlink" title="输入样例2："></a>输入样例2：</h4><pre><code>4 11 100 2 3</code></pre><h4 id="输出样例2："><a href="#输出样例2：" class="headerlink" title="输出样例2："></a>输出样例2：</h4><pre><code>3</code></pre><p>如果 Bessie 引用她的第三篇论文，引用数会变为 $(1,100,3,3)$。上文中提到，这一引用数的 $h$ 指数为 $3$。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>核心就是至少$h$篇引用次数不少于$h$的论文的最大整数$h$，求的结果为$h$</p><p>所以进行有关的枚举,$ans$表示枚举的数</p><p>$c[i]$表示引用次数为$i$的论文的篇数</p><p>$sum$表示满足$h=ans$的文章数量</p><p>所以$sum + min(c[i], l) &gt; ans$那么$ans$还可以进行进一步$+1$操作，否则当前的$ans$就是答案</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-java">import java.util.*;public class Main{    static int n, l;    static int[] a = new int[100010];    static int[] c = new int[100010];    public static void main(String[] args) {        Scanner inScanner = new Scanner(System.in);        n = inScanner.nextInt();        l = inScanner.nextInt();        for(int i = 1; i &lt;= n; i ++)        {            c[i] = inScanner.nextInt();            a[c[i]] ++;        }        inScanner.close();        int ans = 0, sum = n;        for(;ans &lt; n; ans ++)        {            sum -= a[ans];            if(sum + Math.min(a[ans], l) &lt;= ans)                break;        }        System.out.println(ans);    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛年</title>
      <link href="2022/03/16/niu-nian/"/>
      <url>2022/03/16/niu-nian/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p><a href="https://www.acwing.com/problem/content/3373/">3370. 牛年 - AcWing题库</a></p><p>Farmer John 的奶牛们得知最近正在庆祝牛年的到来时十分兴奋。</p><p>牛年总是奶牛们的最爱。</p><p>我们知道，中国历法中每一年所对应的生肖遵循 $12$ 年的周期：<code>Ox, Tiger, Rabbit, Dragon, Snake, Horse, Goat, Monkey, Rooster, Dog, Pig, Rat</code>（牛、虎、兔、龙、蛇、马、羊、猴、鸡、狗、猪、鼠），然后回到牛。</p><p>奶牛 Bessie 自豪地说她是在许多年前的一个牛年出生的。</p><p>她的朋友 Elsie 想要知道她与 Bessie 出生相差多少年，并且希望你能够通过查看农场上若干奶牛出生年份之间的关系来帮助她推算。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入的第一行包含一个整数 $N$。</p><p>以下 $N$ 行每行包含一个 $8$ 个单词的短语，指定了两头奶牛的出生年份之间的关系，格式为 <code>Mildred born in previous Dragon year from Bessie</code>（Mildred 在 Bessie 出生的前一个龙年出生），或 <code>Mildred born in next Dragon year from Bessie</code>（Mildred 在 Bessie 出生的后一个龙年出生）。</p><p>最后一个单词是农场上某一头奶牛的名字，为 “Bessie” 或一头已经在之前的输入中出现过的奶牛。</p><p>第一个单词是农场上某一头奶牛的名字，不为 “Bessie” 且未在之前的输入中出现过。</p><p>所有的奶牛名字不超过 $10$ 个字符，且仅包含字符 $a..z$ 或 $A..Z$。</p><p>第 $5$ 个单词是上述十二生肖之一。</p><p>第 $4$ 个单词是 <code>previous</code>（之前）或 <code>next</code>（之后）之一。</p><p>例如，如果短语为 <code>Mildred born in previous Dragon year from Bessie</code>，则 Mildred 的出生年份为最为接近且严格处于 Bessie 的出生年份之前（不等于）的龙年。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出 Bessie 和 Elsie 的出生年份之间相差的年数。输入保证可以通过给定的信息求出结果。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>$1≤N≤100$</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code class="lang-html">4Mildred born in previous Dragon year from BessieGretta born in previous Monkey year from MildredElsie born in next Ox year from GrettaPaulina born in next Dog year from Bessie</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code class="lang-html">12</code></pre><h4 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h4><p>在以上的输入中，</p><ul><li>Elsie 在 Bessie 之前 $12$ 年出生。</li><li>Mildred 在 Bessie 之前 $9$ 年出生。</li><li>Gretta 在 Bessie 之前 $17$ 年出生。</li><li>Paulina 在 Bessie 之后 $9$ 年出生。</li></ul><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>设置Bessie起始的年份为0，然后进行有关的模拟，进行$+1$或者$-1$操作就行了，模型去遍历</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-java">import java.util.*;public class Main{    static int n;    static String a1, a2, a3, a4, a5, a6, a7, a8;    static String[] q = {"Ox", "Tiger", "Rabbit", "Dragon", "Snake", "Horse", "Goat", "Monkey", "Rooster", "Dog", "Pig", "Rat"};    static Map&lt;String, Integer&gt; ans = new TreeMap&lt;String, Integer&gt;();    public static void main(String[] args) {        Scanner inScanner = new Scanner(System.in);        n = inScanner.nextInt();        ans.put("Bessie", 0);        for(int i = 1; i &lt;= n; i ++)        {            a1 = inScanner.next();            a2 = inScanner.next();            a3 = inScanner.next();            a4 = inScanner.next();            a5 = inScanner.next();            a6 = inScanner.next();            a7 = inScanner.next();            a8 = inScanner.next();            int k;            if(a4.equals("next"))            {                for(k = ans.getOrDefault(a8, 0) + 1;; k ++)                {                    if(q[(k + 12 * 50000) % 12].equals(a5))                        break;                }            }            else             {                for(k = ans.getOrDefault(a8, 0) - 1;; k --)                {                    if(q[(k + 12 * 50000) % 12].equals(a5))                        break;                }            }            ans.put(a1, k);        }        inScanner.close();        System.out.println(Math.abs(ans.get("Elsie") - ans.get("Bessie")));    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>放养但没有完全放养</title>
      <link href="2022/03/16/fang-yang-dan-mei-you-wan-quan-fang-yang/"/>
      <url>2022/03/16/fang-yang-dan-mei-you-wan-quan-fang-yang/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p><a href="https://www.acwing.com/problem/content/3361/">3358. 放养但没有完全放养 - AcWing题库</a></p><p>一个鲜为人知的事实是，奶牛拥有自己的文字：「牛文」。</p><p>牛文由 $26$ 个字母 <code>a</code> 到 <code>z</code> 组成，但是当奶牛说牛文时，可能与我们所熟悉的 <code>abcdefghijklmnopqrstuvwxyz</code> 不同，她会按某种特定的顺序排列字母。</p><p>为了打发时间，奶牛 Bessie 在反复哼唱牛文字母歌，而 Farmer John 好奇她唱了多少遍。</p><p>给定一个小写字母组成的字符串，为 Farmer John 听到 Bessie 唱的字母，计算 Bessie 至少唱了几遍完整的牛文字母歌，使得 Farmer John 能够听到给定的字符串。</p><p>Farmer John 并不始终注意 Bessie 所唱的内容，所以他可能会漏听 Bessie 唱过的一些字母。</p><p>给定的字符串仅包含他记得他所听到的字母。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入的第一行包含 $26$ 个小写字母，为<code>a</code>到<code>z</code>的牛文字母表顺序。</p><p>下一行包含一个小写字母组成的字符串，为 Farmer John 听到 Bessie 唱的字母。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出 Bessie 所唱的完整的牛文字母歌的最小次数。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>字符串的长度不小于 $1$ 且不大于 $1000$。</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code class="lang-html">abcdefghijklmnopqrstuvwxyzmood</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code class="lang-html">3</code></pre><h4 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h4><p>在这个样例中，牛文字母表与日常的字母表的排列一致。</p><p>Bessie 至少唱了三遍牛文字母歌。</p><p>有可能 Bessie 只唱了三遍牛文字母歌，而 Farmer John 听到了以下被标记为大写的字母。</p><pre><code>abcdefghijklMnOpqrstuvwxyzabcdefghijklmnOpqrstuvwxyzabcDefghijklmnopqrstuvwxyz</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>这道理没什么可说的，就是进行遍历两个字符串就行了。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-java">import java.util.*;public class Main{    static StringBuilder s;    static StringBuilder s1;    static int ans = 1;    public static void work()    {        int j = 0, i = 0;        while(j &lt; s1.length())        {            if(s.charAt(i) == s1.charAt(j))                j ++;            i ++;            if(i == s.length())            {                i = 0;                ans ++;            }        }        return;    }    public static void main(String[] args) {        Scanner inScanner = new Scanner(System.in);        s = new StringBuilder(inScanner.next());        s1 = new StringBuilder(inScanner.next());        inScanner.close();        work();        System.out.println(ans);    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你知道你的ABC吗</title>
      <link href="2022/03/16/ni-zhi-dao-ni-de-abc-ma/"/>
      <url>2022/03/16/ni-zhi-dao-ni-de-abc-ma/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p><a href="https://www.acwing.com/problem/content/3349/">3346. 你知道你的ABC吗 - AcWing题库</a></p><p>Farmer John 的奶牛正在 <code>mooZ</code> 视频会议平台上举行每日集会。</p><p>她们发明了一个简单的数字游戏，为会议增添一些乐趣。</p><p>Elsie 有三个正整数 A、B 和 C (A≤B≤C）。</p><p>这些数字是保密的，她不会直接透露给她的姐妹 Bessie。</p><p>她告诉 Bessie 七个范围在 $1…10^9$之间的整数（不一定各不相同），并宣称这是 A、B、C、A+B、B+C、C+A 和 A+B+C 的某种排列。</p><p>给定这七个整数，请帮助 Bessie 求出 A、B 和 C。</p><p>可以证明，答案是唯一的。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入一行，包含七个空格分隔的整数。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出 A、B和 C，用空格分隔。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>$1≤所有输入的整数≤10^9$1</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code class="lang-html">2 2 11 4 9 7 9</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code class="lang-html">2 2 7</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>核心的思想就是：</p><p>假设$a,b$都为正整数，那么$a&lt;a+b同时b&lt;a+b$</p><p>所以思路就出来了，只需要对于这七个数进行排序，然后最大的数减去最小的两个数结果为$N$，其中最小的两个数以及$N$一定是$A,B,C$,然后对于这三个数进行排序，就求出结果了($A&lt;=B&lt;=C$)</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-java">import java.util.*;public class Main{    static int[] a = new int[10];    public static void main(String[] args) {        Scanner inScanner = new Scanner(System.in);        for(int i = 1; i &lt;= 7; i ++)            a[i] = inScanner.nextInt();        Arrays.sort(a, 1, 8);        System.out.printf("%d %d %d", a[1], a[2], a[7] - a[1] - a[2]);        inScanner.close();    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>完全平方数</title>
      <link href="2022/03/07/wan-quan-ping-fang-shu/"/>
      <url>2022/03/07/wan-quan-ping-fang-shu/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p><a href="https://www.acwing.com/problem/content/description/3494/">3491. 完全平方数 - AcWing题库</a></p><p>一个整数 $a$ 是一个完全平方数，是指它是某一个整数的平方，即存在一个整数 $b$，使得 $a=b^2$。</p><p>给定一个正整数 $n$，请找到最小的正整数 $x$，使得它们的乘积是一个完全平方数。</p><h6 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h6><p>输入一行包含一个正整数 $n$。</p><h6 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h6><p>输出找到的最小的正整数 $x$。</p><h6 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h6><p>对于 30% 的评测用例，$1≤n≤1000$，答案不超过 $1000$。<br>对于 60% 的评测用例，$1≤n≤10^8$，答案不超过 $10^8$。<br>对于所有评测用例，$1≤n≤10^12$，答案不超过 $10^{12}$。</p><pre><code class="lang-tex">输入样例1：12输出样例1：3输入样例2：15输出样例2：15</code></pre><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>就是枚举它能整除的平方数最后留下的就是最小数</p><p>例如$a=b<em>b</em>d(其中d不为平方数)$答案就是d，从而得出可以进行枚举，从$2$的平方数进行枚举。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-java">import java.util.*;public class Main{    static long n;    static int cnt = 0;    final static int N = 100000010;    static boolean[] is = new boolean[N];    static int[] vis = new int[6000010];    public static void isprime(int n)    {        for(int i = 2; i &lt;= n; i ++)        {            if(is[i] == false)                vis[cnt ++] = i;            for(int j = 0; j &lt; cnt &amp;&amp; i * vis[j] &lt;= n; j ++)            {                is[i * vis[j]] = true;                if(i % vis[j] == 0)                    break;            }        }        return;    }    public static void main(String[] args) {        Scanner inScanner = new Scanner(System.in);        n = inScanner.nextLong();        for(long i = 2; i * i &lt;= n; i ++)        {            while(n % (i * i) == 0)                n /= i * i;        }        inScanner.close();        System.out.println(n);    }}/*3 30 31 20 2*/</code></pre>]]></content>
      
      
      <categories>
          
          <category> 蓝桥杯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 埃氏筛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最少砝码</title>
      <link href="2022/03/05/zui-shao-fa-ma/"/>
      <url>2022/03/05/zui-shao-fa-ma/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p><a href="https://www.acwing.com/problem/content/description/3427/">3424. 最少砝码 - AcWing题库</a></p><p>你有一架天平。现在你要设计一套砝码，使得利用这些砝码可以称出任意小于等于 $N$ 的正整数重量。</p><p>那么这套砝码最少需要包含多少个砝码？</p><p>注意砝码可以放在天平两边。</p><h6 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h6><p>输入包含一个正整数 $N$。</p><h6 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h6><p>输出一个整数代表答案。</p><h6 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h6><p>对于所有评测用例，$1≤N≤10^9$。</p><h6 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h6><p><code>7</code></p><h5 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h5><p><code>3</code></p><h5 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h5><p>$3$ 个砝码重量是 $1、4、6$，可以称出 $1$ 至 $7$ 的所有重量。</p><pre><code class="lang-html">1 = 1；2 = 6 − 4 (天平一边放 6，另一边放 4)；3 = 4 − 1；4 = 4；5 = 6 − 1；6 = 6；7 = 1 + 6；少于 3 个砝码不可能称出 1 至 7 的所有重量。</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>假设$n$个砝码能够表示的范围为$[0,k]$</p><p>如果第$n+1$个砝码的重量为$2k+1$</p><p>那么$k+1$的重量可以表示为$(2k+1) - k$</p><p>$k+2=(2k+1)-(k-1)$</p><p>…….</p><p>$3k=(2k+1)+(k-1)$</p><p>$3k+1=(2k+1)+k$</p><p>假设$f[i]$为共$i$个砝码能够表示的范围$k$</p><p>所以$f[i+1]=3*f[i]+1$</p><p>$f[1]=3^0=\frac{3^1-1}{2}$</p><p>$f[2]=3^1+3^0=\frac{3^2-1}{2}$</p><p>$f[3]=3^2+3^1+3^0=\frac{3^3-1}{2}$</p><p>…</p><p>$f[n]=\frac{3^n-1}{2}$</p><p>假设输入的值为$m$</p><p>那么$f[n]&gt;=m$</p><p>即$\frac{3^n-1}{2}&gt;=m$</p><p>化简得$3^n&gt;=2m+1$</p><p>$n&gt;=log_3(2m+1)$</p><p>得出：$n=\lceil log_3(2m+1) \rceil$</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-java">import java.util.*;public class Main{    static int n, cnt = 0;    public static void main(String[] args) {        Scanner inScanner = new Scanner(System.in);        n = inScanner.nextInt();        inScanner.close();        System.out.println((int)Math.ceil(Math.log(2*n+1)/Math.log(3)));    }}/*3 30 31 20 2*/</code></pre>]]></content>
      
      
      <categories>
          
          <category> 蓝桥杯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>左孩子右兄弟</title>
      <link href="2022/03/04/zuo-hai-zi-you-xiong-di/"/>
      <url>2022/03/04/zuo-hai-zi-you-xiong-di/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p><a href="https://www.acwing.com/problem/content/description/3425/">3422. 左孩子右兄弟 - AcWing题库</a></p><p>对于一棵多叉树，我们可以通过 “左孩子右兄弟” 表示法，将其转化成一棵二叉树。</p><p>如果我们认为每个结点的子结点是无序的，那么得到的二叉树可能不唯一。</p><p>换句话说，每个结点可以选任意子结点作为左孩子，并按任意顺序连接右兄弟。</p><p>给定一棵包含 N 个结点的多叉树，结点从 1 至 N 编号，其中 1 号结点是根，每个结点的父结点的编号比自己的编号小。</p><p>请你计算其通过 “左孩子右兄弟” 表示法转化成的二叉树，高度最高是多少。</p><p>注：只有根结点这一个结点的树高度为 0。</p><p>例如如下的多叉树：</p><p><img src="/2022/03/04/zuo-hai-zi-you-xiong-di/0.png" alt=""></p><p>可能有以下 3 种 (这里只列出 3 种，并不是全部) 不同的 “左孩子右兄弟”表示：</p><p><img src="/2022/03/04/zuo-hai-zi-you-xiong-di/1.png" alt=""></p><p>其中最后一种高度最高，为 4。</p><h6 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h6><p>输入的第一行包含一个整数 N。</p><p>以下 N−1 行，每行包含一个整数，依次表示 2 至 N 号结点的父结点编号。</p><h6 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h6><p>输出一个整数表示答案。</p><h6 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h6><p>对于 30% 的评测用例，$1≤N≤20$；<br>对于所有评测用例，$1≤N≤10^5$。</p><h6 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h6><p>5<br>1<br>1<br>1<br>2</p><h6 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h6><p>4</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>这道题思路十分清晰，就是类似于一个递归，已知要把多叉树变成二叉树，显然每个节点只能保留一个子树，那么就变成了保留哪个子树之后二叉树的高度最高，因此可以得出：</p><p>最终的高度=保留子树的高度+其兄弟节点的个数</p><p>这显然可以用递归解决，记录每个节点的孩子以及孩子的数量。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-java">import java.util.*;public class Main{    final static int N = 100010;    static int[] E = new int[N];    static int[] nxt = new int[N];    static int[] head = new int[N];    static int[] sum = new int[N];    static int n, cnt = 0;    public static void add(int to, int from)    {        E[++ cnt] = from;        nxt[cnt] = head[to];        head[to] = cnt;    }    public static int dfs(int root)    {        int ans = 0;        for(int i = head[root]; i != 0; i = nxt[i])        {            ans = Math.max(ans, dfs(E[i]) + sum[root]);        }        return ans;    }    public static void main(String[] args) {        Scanner inScanner = new Scanner(System.in);        n = inScanner.nextInt();        head[1] = 0;        nxt[1] = 0;        for(int i = 2; i &lt;= n; i ++)        {            int t = inScanner.nextInt();            add(t, i);            sum[t] ++;        }        inScanner.close();        System.out.println(dfs(1));    }}/*3 30 31 20 2*/</code></pre>]]></content>
      
      
      <categories>
          
          <category> 蓝桥杯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异或数列</title>
      <link href="2022/03/03/yi-huo-shu-lie/"/>
      <url>2022/03/03/yi-huo-shu-lie/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>Alice 和 Bob 正在玩一个异或数列的游戏。</p><p>初始时，Alice 和 Bob 分别有一个整数 a 和 b（初始时，a,b 均为 0），有一个给定的长度为 n 的公共数列 $X_1,X_2,⋅⋅⋅,X_n$。</p><p>Alice 和 Bob 轮流操作，Alice 先手，每步可以在以下两种选项中选一种：</p><p>选项 1：从数列中选一个 $X_i$ 给 Alice 的数异或上，或者说令 a 变为 $a⊕X_i$。（其中 $⊕$ 表示按位异或）<br>选项 2：从数列中选一个 $X_i$ 给 Bob 的数异或上，或者说令 b 变为 $b⊕X_i$。<br>每个数 $X_i$ 都只能用一次，当所有 $X_i$ 均被使用后（n 轮后）游戏结束。</p><p>游戏结束时，拥有的数比较大的一方获胜，如果双方数值相同，即为平手。</p><p>现在双方都足够聪明，都采用最优策略，请问谁能获胜？</p><h6 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h6><p>每个评测用例包含多组询问。询问之间彼此独立。</p><p>输入的第一行包含一个整数 $T$，表示询问数。</p><p>接下来 T 行每行包含一组询问。其中第 $i$ 行的第一个整数 $n<em>i$ 表示数列长度，随后 $n_i$ 个整数 $X_1,X_2,⋅⋅⋅,X</em>{ni}$ 表示数列中的每个数。</p><h6 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h6><p>输出 T 行，依次对应每组询问的答案。</p><p>每行包含一个整数 1、0 或 −1 分别表示 Alice 胜、平局或败。</p><h6 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h6><p>对于所有评测用例，$1≤T≤2×10^5$，$1≤∑X_i≤2×10^5$，$0≤X_i&lt;2^{20}$。</p><h6 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h6><p>4<br>1 1<br>1 0<br>2 2 1<br>7 992438 1006399 781139 985280 4729 872779 563580</p><h6 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h6><p>1<br>0<br>1<br>1</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>这道题是典型的博弈，如果所有$X_i$的异或和为0，那么他们两者平局</p><p>如果异或和不为0，那么可以看作每个二进制位的异或和，那么只需要看哪个位的1的数量为奇数，且该位置靠高位，然后看这个位的1的数量为1，那么先手胜利</p><p>如果这个位1的数量大于1，且为奇数，那么可以分为两种情况：</p><p>​    1.总个数为奇数，那么0的个数就为偶数，必然是先手赢，首先取该位为1的数上的，然后变成1的数量偶数，0的数量偶数，看后手取哪部分，先手模仿即可胜利。</p><p>​    2.总个数为偶数的，那么0的个数就为奇数，如果先手取该位为0的数，那么后手模仿，后手胜利，如果先手取该位为1的数，那么就变成第一种情况，后手胜利。</p><p>具体看代码。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-java">import java.util.*;public class Main{    static int T;    static int[] q = new int[100];    public static void get_bit(int a)    {        int t = 0;        while(a &gt; 0)        {            if(a % 2 == 1)                q[t] ++;            a &gt;&gt;= 1;            t ++;        }        return;    }    public static void main(String[] args) {        Scanner inScanner = new Scanner(System.in);        T = inScanner.nextInt();        while(T --&gt; 0)        {            int n;            int sum = 0;            n = inScanner.nextInt();            Arrays.fill(q, 0);            for(int i = 1; i &lt;= n; i ++)            {                int a = inScanner.nextInt();                get_bit(a);                sum ^= a;            }            if(sum == 0)                System.out.println(0);            else            {                int cnt = -1;                int u = sum;                while(u &gt; 0)                {                    cnt ++;                    u &gt;&gt;= 1;                }                if(q[cnt] == 1 || (q[cnt] % 2 == 1 &amp;&amp; n % 2 == 1))                    System.out.println(1);                else                    System.out.println(-1);            }        }        inScanner.close();    }}/*3 30 31 20 2*/</code></pre>]]></content>
      
      
      <categories>
          
          <category> 蓝桥杯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>括号序列</title>
      <link href="2022/03/02/gua-hao-xu-lie/"/>
      <url>2022/03/02/gua-hao-xu-lie/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p><a href="https://www.acwing.com/problem/content/3423/">3420. 括号序列 - AcWing题库</a></p><p>给定一个括号序列，要求尽可能少地添加若干括号使得括号序列变得合法，当添加完成后，会产生不同的添加结果，请问有多少种本质不同的添加结果。</p><p>两个结果是本质不同的是指存在某个位置一个结果是左括号，而另一个是右括号。</p><p>例如，对于括号序列 <code>((()</code>，只需要添加两个括号就能让其合法，有以下几种不同的添加结果：<code>()()()、()(())、(())()、(()())</code> 和 <code>((()))</code>。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入一行包含一个字符串 ss，表示给定的括号序列，序列中只有左括号和右括号。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数表示答案，答案可能很大，请输出答案除以 $1000000007$(即 $109+7$) 的余数。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>对于 40% 的评测用例，$|s|≤200$。<br>对于所有评测用例，$1≤|s|≤5000$。</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>((()</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>5</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>首先我们需要添加的是左括号以及右括号，然后添加的左右括号都是相互独立的。</p><p>考虑到我们只能在空隙中添加，能添加左右括号的只有<code>)(</code>这种情况，而<code>()</code>是无效的，相当于自己添加一个左右合法括号，是多此一举，由此可知，我们只需要求出左括号的添加方案数，右括号的添加方案数，两者一乘就是答案。</p><p><img src="/2022/03/02/gua-hao-xu-lie/0.jpg" alt=""></p><p>然后我们以右括号为断点，划分区域，然后忘划分的区域中添加左括号就ok了</p><p>$f[i][j]$表示前$i$个右括号，添加$j$个左括号的合法方案数。</p><p>那么我们需要预先处理每个区域中至少添加的左括号数量，因为小于该数量，那就不合法了，多了可以在后面进行添加的时候进行修改。</p><p>$f[1][i]=1$ </p><p>转移方程:</p><p>$f[i][j]=f[i][j]+f[i-1]<a href="0<=k<=j">k</a>$</p><p>进一步优化：</p><p>$f[i][j]=f[i-1][0]+f[i-1][1]+…+f[i][j]$</p><p>$f[i][j+1]=f[i-1][0]+…+f[i][j]+f[i-1][j+1]$</p><p>所以可以得出:</p><p>$f[i][j]=f[i][j-1]+f[i-1][j]$</p><pre><code class="lang-java">import java.util.*;public class Main{    static StringBuilder s;    final static int mod = 1000000007;    static int[][] f = new int[5010][5010];    static int[] sum = new int[5010];    static long ans;    public static int work(int len)    {        int lcnt = 0, rcnt = 0, cnt = 0;        for(int i = 0; i &lt;= len; i ++)            Arrays.fill(f[i], 0);        for(int i = 0; i &lt; len; i ++)        {            if(s.charAt(i) == '(')                lcnt ++;            else            {                rcnt ++;                cnt ++;                if(lcnt != 0)                {                    lcnt --;                    rcnt --;                }                sum[cnt] = rcnt;            }        }        for(int i = sum[1]; i &lt;= len; i ++)            f[1][i] = 1;//        for(int i = 2; i &lt;= cnt; i ++)//        {//            for(int j = sum[i]; j &lt;= len; j ++)//                for(int k = 0; k &lt;= j; k ++)//                    f[i][j] = (f[i][j] + f[i-1][k]) % mod;//        }        for(int i = 2; i &lt;= cnt; i ++)        {            for(int j = 0; j &lt;= sum[i]; j ++)                f[i][sum[i]] = (f[i][sum[i]] + f[i - 1][j]) % mod;            for(int j = sum[i] + 1; j &lt;= len; j ++)                f[i][j] = (f[i][j - 1] + f[i - 1][j]) % mod;        }        return f[cnt][rcnt];    }    public static void main(String[] args) {        Scanner inScanner = new Scanner(System.in);        s = new StringBuilder(inScanner.next());        ans = work(s.length());        for(int i = 0; i &lt; s.length(); i ++)        {            if(s.charAt(i) == ')')                s.setCharAt(i, '(');            else                s.setCharAt(i, ')');        }        s = s.reverse();        ans = (ans * work(s.length())) % mod;        System.out.println(ans % mod);        inScanner.close();    }}/*3 30 31 20 2*/</code></pre>]]></content>
      
      
      <categories>
          
          <category> 蓝桥杯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杨辉三角形</title>
      <link href="2022/02/28/yang-hui-san-jiao-xing/"/>
      <url>2022/02/28/yang-hui-san-jiao-xing/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p><img src="/2022/02/28/yang-hui-san-jiao-xing/0.png" alt=""></p><p>思路：</p><p>首先都知道杨辉三角形就是组合数，每一个数都可以被表示出来</p><p><img src="/2022/02/28/yang-hui-san-jiao-xing/1.png" alt=""></p><p>如图所示，杨辉三角是左右对称的，所以只用看一半即可</p><p><img src="/2022/02/28/yang-hui-san-jiao-xing/2.png" alt=""></p><p>这里我们从右斜着看每一行，也就是</p><p><img src="/2022/02/28/yang-hui-san-jiao-xing/3.png" alt=""></p><p>我们可以很明显的从图中发现除了第一行外，每一行都是单调递增的，又因为杨辉三角就是组合数，所以每一行的最小值表示为，$k$是当前行第几个数，如下图所示</p><p><img src="/2022/02/28/yang-hui-san-jiao-xing/3.png" alt=""></p><p>因为是斜着的每一行是单调递增的，所以我们可以用二分来找到目标值$n$，又因为每一斜行也是单调递增的，所以我们从最里面开始往外找</p><p>   上边界就是$l=2k$</p><p>   下边界就是$r=n$</p><p>我们都知道组合数越靠近中间越大，所以由n的范围是$10^9$可以通过计算机算出$\binom{34}{17}&gt;10^9, \binom{32}{16}&lt;10^9$</p><p>所以我们可以枚举每一斜行的开头元素(最小元素)$k$,从$16$开始枚举</p><p>二分的原理就是如果$C_{mid}^k&gt;=n$,取左区间，否则取右区间。。</p><p>当我们找到了这个数的时候即$C_k^r == n$</p><p>我们通过规律可以发现$r$为前面共有多少行</p><p>第一行$1$个数</p><p>第二行$2$个数</p><p>第三行$3$个数</p><p>…</p><p>第$n$行$n$个数</p><p>也就是说前面共有$ \frac{r(r+1)}{2}$，$k$为这一行第几个(下标都是从0开始),所以最终的个数是$ \frac{r(r+1)}{2} + k + 1$</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-java">import java.util.*;public class Main {    static int n;    public static long C(int m, int k)    {        long sum = 1;        for(int i = m, j = 1; j &lt;= k; i --, j ++)        {            sum = sum * i / j;            if(sum &gt; n)                return sum;        }        return sum;    }    public static boolean check(int k)    {        int l = 2 *k, r = Math.max(l, n);        while(l &lt; r)        {            int mid = l + r &gt;&gt; 1;            if(C(mid, k) &gt;= n)                r = mid;            else                l = mid + 1;        }        if(C(r, k) != n)            return false;        long ans = r;        System.out.println(ans * (ans + 1) / 2 + k + 1);        return true;    }    public static void main(String[] args) {        Scanner in = new Scanner(System.in);        n = in.nextInt();        in.close();        for(int i = 16; i &gt;= 0; i --)            if(check(i))                break;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 蓝桥杯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双向排序</title>
      <link href="2022/02/28/shuang-xiang-pai-xu/"/>
      <url>2022/02/28/shuang-xiang-pai-xu/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p><a href="https://www.acwing.com/problem/content/3422/">3419. 双向排序 - AcWing题库</a></p><p>给定序列 $(a_1,a_2,⋅⋅⋅,a_n)=(1,2,⋅⋅⋅,n)$，即 $a_i=i$。</p><p>小蓝将对这个序列进行 $m$ 次操作，每次可能是将 $a<em>1,a_2,⋅⋅⋅,a</em>{q<em>i}$ 降序排列，或者将 $a</em>{q<em>i},a</em>{q_i+1},⋅⋅⋅,a_n$ 升序排列。</p><p>请求出操作完成后的序列。</p><h5 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h5><p>输入的第一行包含两个整数 $n,m$，分别表示序列的长度和操作次数。</p><p>接下来 $m$ 行描述对序列的操作，其中第 $i$ 行包含两个整数 $p<em>i,q_i$ 表示操作类型和参数。当 $p_i$=0 时，表示将 $a_1,a_2,⋅⋅⋅,a</em>{q<em>i}$ 降序排列；当 $p_i$=1 时，表示将 $a</em>{q<em>i},a</em>{q_i+1},⋅⋅⋅,a_n$ 升序排列。</p><h5 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h5><p>输出一行，包含 $n$ 个整数，相邻的整数之间使用一个空格分隔，表示操作完成后的序列。</p><p>数据范围<br>对于 30% 的评测用例，$n,m≤1000$；<br>对于 60% 的评测用例，$n,m≤5000$；<br>对于所有评测用例，$1≤n,m≤10^5$，$0≤p_i≤1，1≤q_i≤n$。</p><pre><code class="lang-html">输入样例：3 30 31 20 2输出样例：3 1 2</code></pre><p>思路：</p><p>首先起始的序列是升序的，所以开始的时候是后缀序列是不需要操作的，只有碰到第一个前缀序列是需要操作的，然后可以进行有关的优化</p><p>假设蓝色序列为原序列</p><p><img src="/2022/02/28/shuang-xiang-pai-xu/0.png" alt="原序列"></p><h6 id="优化一"><a href="#优化一" class="headerlink" title="优化一"></a>优化一</h6><p>如果是多个前缀序列连续或者多个后缀序列连续，可以进行合并。</p><p><img src="/2022/02/28/shuang-xiang-pai-xu/1.png" alt=""></p><p>可以选择其中最长的一个前缀序列然后进行操作，同样后缀序列也是如此。</p><h6 id="优化二："><a href="#优化二：" class="headerlink" title="优化二："></a>优化二：</h6><p>前缀序列a，后缀序列b，前缀序列c</p><p>前缀序列c的长度$&lt;$前缀序列a的长度</p><p><img src="/2022/02/28/shuang-xiang-pai-xu/2.png" alt=""></p><p>如图所示，对于后缀序列b的A部分的序列是不需要操作的，而对于前缀序列c的C部分的序列也是不需要操作的。</p><h6 id="优化三："><a href="#优化三：" class="headerlink" title="优化三："></a>优化三：</h6><p>前缀序列a，后缀序列b，前缀序列c</p><p>前缀序列c的长度$&gt;=$前缀序列a的长度</p><p><img src="/2022/02/28/shuang-xiang-pai-xu/3.png" alt=""></p><p>在图中很明显发现A部分不需要任何操作，那么A部分之外的序列，只需要最后一次的前缀操作，即c操作一次降序排序就行了。</p><p>以上就是三个小优化，可以通过栈去模拟就行，然后不需要进行排序，进行填充就行。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-java">import java.util.*;public class Main{    static int n, m;    static node[] a = new node[100010];    static int[] ans = new int[100010];    public static void main(String[] args) {        Scanner inScanner = new Scanner(System.in);        n = inScanner.nextInt();        m = inScanner.nextInt();        int cnt = 0;        for(int i = 1; i &lt;= m; i ++)        {            int op = inScanner.nextInt();            int p = inScanner.nextInt();            if(op == 0)            {                while(cnt &gt; 0 &amp;&amp; a[cnt].x == 0)                    p = Math.max(p, a[cnt --].v);                while(cnt &gt;= 2 &amp;&amp; a[cnt - 1].v &lt;= p)                    cnt -= 2;                ++ cnt;                //a[++ cnt] = new node(op, p);            }            else if(cnt != 0)            {                while(cnt &gt; 0 &amp;&amp; a[cnt].x == 1)                    p = Math.min(p, a[cnt --].v);                while(cnt &gt;= 2 &amp;&amp; a[cnt - 1].v &gt;= p)                    cnt -= 2;                ++ cnt;                //a[++ cnt] = new node(op, p);            }            a[cnt] = new node(op, p);        }        int l = 1, r = n, k = n;        for(int i = 1; i &lt;= cnt; i ++)        {            if(a[i].x == 0)            {                while(r &gt; a[i].v &amp;&amp; l &lt;= r)                    ans[r --] = k --;            }            else            {                while(l &lt; a[i].v &amp;&amp; l &lt;= r)                    ans[l ++] = k --;            }            if(l &gt; r)                 break;        }        if(cnt % 2 == 1)        {            while(l &lt;= r)                ans[l ++] = k --;        }        else        {            while(l &lt;= r)                ans[r --] = k --;        }        inScanner.close();        for(int i = 1; i &lt;= n; i ++)            System.out.printf("%d ", ans[i]);    }    static class node {        int x, v;        public node(int x, int v)        {            this.x = x;            this.v = v;        }    }}/*3 30 31 20 2*/</code></pre>]]></content>
      
      
      <categories>
          
          <category> 蓝桥杯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>砝码称重</title>
      <link href="2022/02/28/fa-ma-cheng-chong/"/>
      <url>2022/02/28/fa-ma-cheng-chong/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p><a href="https://www.acwing.com/problem/content/3420/">3417. 砝码称重 - AcWing题库</a></p><p>你有一架天平和 $N$ 个砝码，这 4N$ 个砝码重量依次是 $W_1,W_2,⋅⋅⋅,W_N$。</p><p>请你计算一共可以称出多少种不同的正整数重量？</p><p>注意砝码可以放在天平两边。</p><h5 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h5><p>输入的第一行包含一个整数 $N$。</p><p>第二行包含 $N$ 个整数$W_1,W_2,W_3,⋅⋅⋅,W_N$。</p><h5 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h5><p>输出一个整数代表答案。</p><h5 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h5><p>对于 50% 的评测用例，$1≤N≤15$。<br>对于所有评测用例，$1≤N≤100$，$N$ 个砝码总重不超过 $10^5$。</p><h5 id="样例："><a href="#样例：" class="headerlink" title="样例："></a>样例：</h5><pre><code class="lang-html">31 4 6输出10</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>这道题目仔细想想是一个dp问题，可以简单的推断出每个砝码都有选和不选两种状态，一般涉及这种问题的多半需要动态规划，寻找转移方程。</p><p>设$f[i,j]$代表前$i$个砝码是否能称出$j$,$0$代表不能，$1$代表能.</p><p>然后就是寻找相互的转移方程，可以分成两个途径，选第$i$个或者不选</p><p>选第$i$个：那么前$i-1$个就能称出$j+a[i]$或者$|j-a[i]|$（$j-a[i]$可能为负数，直接取绝对值）才能称出$j$</p><p>不选第$i$个：前$i - 1$个就能称出$j$</p><p>所以转移方程就可以是</p><p>$f[i,j]=f[i-1,j] \cup f[i-1,j+a[i]] \cup f[i-1, |j-a[i]| ]$</p><p>然后最后遍历一下$f<a href="0<i<=10^5">n,i</a>$，记录一下能称出的次数就解决了。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-java">import java.util.*;public class Main{    static int n, sum = 0, ans = 0;    final static int N = 200010;    static int[] a = new int[110];    static boolean[][] dp = new boolean[110][N];    public static void main(String[] args) {        Scanner inScanner = new Scanner(System.in);        n = inScanner.nextInt();        for(int i = 1; i &lt;= n; i ++)        {            a[i] = inScanner.nextInt();            sum += a[i];        }        dp[0][0] = true;        for(int i = 1; i &lt;= n; i ++)        {            for(int j = 0; j &lt;= sum; j ++)            {                dp[i][j] = dp[i - 1][j] || dp[i - 1][j + a[i]] || dp[i - 1][Math.abs(j - a[i])];            }        }        for(int i = 1; i &lt;= sum; i ++)            if(dp[n][i])                ans ++;        inScanner.close();        System.out.println(ans);    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 蓝桥杯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>奖项</title>
      <link href="2022/02/20/jiang-xiang/"/>
      <url>2022/02/20/jiang-xiang/</url>
      
        <content type="html"><![CDATA[<ul><li>2006年《时尚周刊》年度风云人物</li><li>《感动中国》2008年度人物特别奖</li><li>联合国2019年度“地球卫士奖”</li><li>北京冬奥会2022年奥林匹克杯</li></ul>]]></content>
      
      
      <categories>
          
          <category> 奖项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 奖项 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java</title>
      <link href="2022/02/20/java/"/>
      <url>2022/02/20/java/</url>
      
        <content type="html"><![CDATA[<h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><pre><code class="lang-java">Scanner cin1 = new Scanner(System.in ) ;Scanner cin2 = new Scanner(new BufferedInputstream(System.in ) ) ;</code></pre><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p><a href="https://aspire-zero.github.io/2022/02/15/feng-kuang-de-ke-xue-jia/">疯狂的科学家 | 姜小白 (aspire-zero.github.io)</a></p><h4 id="排序问题"><a href="#排序问题" class="headerlink" title="排序问题"></a>排序问题</h4><p>1、Arrays.sort()<br>（1）数字排序         </p><pre><code class="lang-java">int[] num =newint[]{4,2,3,5,-8,5,2,3};      Arrays.sort(num);for(int i = 0; i &lt; 8;i++)    System.out.print(num[i]+”,”);</code></pre><p>输出结果：-8,2,2,3,3,4,5,5,</p><p>（2）字符串排序（先大写后小写原则）        </p><pre><code class="lang-java">String[] s = new String[]{"Z","a","A","z"};Arrays.sort(s);for(int i = 0; i &lt; 4;i++)    System.out.print(s[i] +",");输出结果：A,Z,a,z,</code></pre><p>（3）严格按照字母表排序（即忽略大小写）      </p><pre><code class="lang-java">String[] s = new String[]{"Z","a","A","z"};     Arrays.sort(s,String.CASE_INSENSITIVE_ORDER);for(int i = 0; i &lt; 4;i++)    System.out.print(s[i] +",");</code></pre><h4 id="Java中有两个类BigDecimal（表示浮点数）和BigInteger（表示整数）"><a href="#Java中有两个类BigDecimal（表示浮点数）和BigInteger（表示整数）" class="headerlink" title="Java中有两个类BigDecimal（表示浮点数）和BigInteger（表示整数）"></a>Java中有两个类BigDecimal（表示浮点数）和BigInteger（表示整数）</h4><p>使用这两个类的时候需要加上import java.math.*;</p><p>Ⅰ基本函数：</p><pre><code class="lang-java">（1）valueOf(parament); 将参数转换为指定类型例如：int a = 3;BigInteger b = BigInteger.valueOf(a);即b = 3String s = “1234”;BigInteger b = BigInteger.valueOf(s);即b = 1234（2）add(); //大数加法例如：BigInteger a = new BigInteger(“11”);BigInteger b = new BigInteger(“22”);a.add(b);即a = 33（3）substract(); //减法（4）multiply(); //乘法（5）pided(); //相除取整（6）remainder(); //取余（7）pow(); //a.pow(b) = a ^ b（8）gcd(); //最大公约数（9）abs(); //绝对值（10）negate(); //取反数（11）mod(); //a.mod(b) = a % b = a.remainder(b)（12）max(); min();（13）public int compareTo(); //比较（14）boolean equals(); //比较是否相等（15）BigIntergerde 构造函数一般用到以下两种：BigInteger(String val);将指定字符串转换为十进制表示形式；BigInteger(String val,int radix);将指定基数的 BigInteger 的字符串表示形式转换为 BigInteger例如：BigInteger b = new BigInteger("1010",2);System.out.println(b);输出：10Ⅱ.基本常量：A=BigInteger.ONE //=1B=BigInteger.TEN //=10C=BigInteger.ZERO //=0</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gitalk出现403错误</title>
      <link href="2022/02/18/gitalk-chu-xian-403-cuo-wu/"/>
      <url>2022/02/18/gitalk-chu-xian-403-cuo-wu/</url>
      
        <content type="html"><![CDATA[<h1 id="Gitalk-403报错"><a href="#Gitalk-403报错" class="headerlink" title="Gitalk 403报错"></a>Gitalk 403报错</h1><p>自己的Gitalk配置完登录显示显示403报错，上网查看相关资料，如果是本地服务器配置可以进行nginx反向代理解决，但问题我自己的博客是直接部署到github上面，发现是是因为cors-anywhere.herokuapp.com，网站受限了。</p><p><img src="/2022/02/18/gitalk-chu-xian-403-cuo-wu/image-20220218214727609.png" alt="403错误"></p><p>解决方式：<br><a href="https://cors-anywhere.herokuapp.com/corsdemo点开该网站，进行权限受理。">https://cors-anywhere.herokuapp.com/corsdemo点开该网站，进行权限受理。</a></p><p><img src="/2022/02/18/gitalk-chu-xian-403-cuo-wu/0.png" alt="授权"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Gitalk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>菊花链</title>
      <link href="2022/02/17/ju-hua-lian/"/>
      <url>2022/02/17/ju-hua-lian/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p><a href="https://www.acwing.com/problem/content/3350/">3347. 菊花链 - AcWing题库</a></p><p>每天，作为她绕农场行走的一部分，奶牛 Bessie 会经过她最喜爱的草地，其中种有 N 朵花（五颜六色的雏菊），编号为 1…N，排列成一行。</p><p>花 i 有 pi 朵花瓣。</p><p>作为一名崭露头角的摄影家，Bessie 决定给这些花拍些照片。</p><p>具体地说，对于每一对满足 1≤i≤j≤N 的花 (i,j)，Bessie 会给从花 i 到花 j 之间的所有花（包括 i 和 j）拍一张照。</p><p>后来 Bessie 查看这些照片时注意到有些照片里存在「平均」的花——一朵恰好有 P 朵花瓣的花，其中 P 等于照片中所有花的花瓣数量的平均值。</p><p>Bessie 的照片中有几张存在平均的花？</p><h5 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h5><p>输入的第一行包含 N。</p><p>第二行包含 N 个空格分隔的整数 p1…pN。</p><h5 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h5><p>输出存在平均的花的照片数量。</p><h5 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h5><p>1≤N≤100,<br>1≤pi≤1000</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-java">import java.util.*;public class Main {    static int N = 100010;    static int n, ans = 0, l = 1000010;    static int[] a  = new int[1010];    static int[] p  = new int[1010];    public static void main(String[] args) {        Scanner inScanner = new Scanner(System.in);        n = inScanner.nextInt();        for(int i = 1; i &lt;= n; i ++)        {            p[i] = inScanner.nextInt();            a[i] = a[i - 1] + p[i];        }        inScanner.close();        ans = n;        for(int i = 1; i &lt; n; i ++)        {            for(int j = i + 1; j &lt;= n; j ++)            {                int t = (a[j] - a[i - 1]) / (j - i + 1);                if(t * (j - i + 1) == a[j] - a[i - 1])                    for(int k = i; k &lt;= j; k ++)                    {                        if(p[k] == t)                        {                            ans ++;                            break;                        }                    }            }        }        System.out.printf("%d", ans);    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>社交距离II</title>
      <link href="2022/02/16/she-jiao-ju-chi-ii/"/>
      <url>2022/02/16/she-jiao-ju-chi-ii/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p><a href="https://www.acwing.com/problem/content/1662/">1660. 社交距离 II - AcWing题库</a></p><p>由于高传染性的牛传染病 COWVID-19 的爆发，Farmer John 非常担忧他的奶牛们的健康。</p><p>尽管他尽了最大努力使他的 N 头奶牛们践行“社交距离”，还是有许多奶牛不幸染上了疾病。</p><p>编号为 1…N 的奶牛们分别位于一条长直道路上的不同位置（相当于一维数轴），奶牛 i 位于位置 xi。</p><p>Farmer John 知道存在一个半径 R，任何与一头被感染的奶牛距离不超过 R 单位的奶牛也会被感染（然后会传染给与其距离 R 单位内的奶牛，以此类推）。</p><p>不幸的是，Farmer John 并不确切知道 R 的值。</p><p>他只知道他的哪些奶牛被感染了。</p><p>给定这个数据，求出起初感染疾病的奶牛的最小数量。</p><h5 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h5><p>输入的第一行包含 N。</p><p>以下 N 行每行用两个整数 x 和 s 描述一头奶牛，其中 x 为位置，s 为 0 表示健康的奶牛，1 表示染病的奶牛，并且所有可能因传播而染病的奶牛均已染病。</p><h5 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h5><p>输出在疾病开始传播之前已经得病的奶牛的最小数量。</p><h5 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h5><p>1≤N≤1000,<br>0≤x≤10^6</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-java">import java.util.*;public class Main {    static int N = 100010;    static int n, ans = 0, l = 1000010;    static node[] a = new node[1010];    public static void main(String[] args) {        Scanner inScanner = new Scanner(System.in);        n = inScanner.nextInt();        for(int i = 1; i &lt;= n; i ++)            a[i] = new node(inScanner.nextInt(), inScanner.nextInt());        inScanner.close();        Arrays.sort(a, 1, n + 1);        for(int i = 2; i &lt;= n; i ++)            if((a[i].v ^ a[i - 1].v) == 1)            {                int t = a[i].x - a[i - 1].x;                l = t &lt; l ? t : l;            }        if(a[1].v == 1)            ans ++;        for(int i = 2; i &lt;= n; i ++)        {            if(a[i].v == 1 &amp;&amp; a[i - 1].v == 0)                ans ++;            else if(a[i].v + a[i - 1].v == 2)             {                if(a[i].x - a[i - 1].x &gt;= l)                    ans ++;            }        }        System.out.printf("%d", ans);    }}class node implements Comparable&lt;node&gt;{    int x, v;    public node(int x, int v)    {        this.x = x;        this.v = v;    }    public int compareTo(node o)    {        return x - o.x;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>疯狂的科学家</title>
      <link href="2022/02/15/feng-kuang-de-ke-xue-jia/"/>
      <url>2022/02/15/feng-kuang-de-ke-xue-jia/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p><a href="https://www.acwing.com/problem/content/1674/">1672. 疯狂的科学家 - AcWing题库</a></p><p>Farmer John 的远房亲戚 Ben 是一个疯狂的科学家。</p><p>通常这会在家庭聚会时造成不小的摩擦，但这偶尔也会带来些好处，尤其是当 Farmer John 发现他正面对一些有关他的奶牛们的独特而不寻常的问题时。</p><p>Farmer John 当前正面对一个有关她的奶牛们的独特而不寻常的问题。</p><p>他最近订购了 N 头奶牛，包含两种不同品种：荷斯坦牛和更赛牛。</p><p>他在订单中用一个长为 N 的字符串来指定奶牛，其中的字符为 H（表示荷斯坦牛）或 G（表示更赛牛）。</p><p>不幸的是，当这些奶牛到达他的农场，他给她们排队时，她们的品种组成的字符串与原先的不同。</p><p>我们将这两个字符串称为 A 和 B，其中 A 是 Farmer John 原先想要的品种字符组成的字符串，B 是他的奶牛们到达时组成的字符串。</p><p>Farmer John 并没有简单地检查重新排列 B 中的奶牛是否能得到 A，而是请他的远房亲戚 Ben 利用他的科学才华来解决这一问题。</p><p>经过数月的研究，Ben 发明了一台不同寻常的机器：奶牛品种转换机3000，能够选择任意奶牛组成的子串并反转她们的品种：在这个子串中的所有 H 变为 G，所有 G 变为 H。</p><p>Farmer John 想要求出将他当前的序列 B 变为他本来订购时想要的 A 需要使用这台机器的最小次数。</p><p>然而，Ben 的疯狂的科学家技能并不会处理开发奇异机器以外的事，所以你需要帮助 Farmer John 解决这个计算难题。</p><h5 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h5><p>输入的第一行包含 N，以下两行包含字符串 A 和 B。每个字符串均包含 N 个字符，字符均为 H 和 G 之一。</p><h5 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h5><p>输出将 B 变为 A 需要使用机器的最小次数。</p><h5 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h5><p>1≤N≤1000</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-java">import java.util.*;public class Main {    static int N = 100010;    static int n, ans = 0;    static boolean f = false;    public static void main(String[] args) {        Scanner inScanner = new Scanner(System.in);        n = inScanner.nextInt();        StringBuilder s = new StringBuilder(inScanner.next());        StringBuilder s1 = new StringBuilder(inScanner.next());        for(int i = 0; i &lt; n; i ++)        {            if(!f &amp;&amp; s.charAt(i) != s1.charAt(i))            {                f = true;                ans ++;            }            if(s.charAt(i) == s1.charAt(i))                f = false;        }        inScanner.close();        System.out.printf("%d", ans);    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拍照</title>
      <link href="2022/02/14/pai-zhao/"/>
      <url>2022/02/14/pai-zhao/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p><a href="https://www.acwing.com/problem/content/1445/">1443. 拍照 - AcWing题库</a></p><p>农夫约翰在给他编号为 1…N 的 N 头奶牛排队拍照。</p><p>约翰一开始计划从左向右数第 i 个位置排编号为 ai 的奶牛，他在一张纸上写下了排列 a1,a2,…,aN。</p><p>不幸的是，这张纸刚刚被小偷偷走了！</p><p>幸好约翰仍然有机会恢复他之前写下的排列。</p><p>在这张纸被偷走之前，奶牛贝茜记录了序列 b1,b2,…,bN−1，对于每一个 1≤i&lt;N 满足 bi=ai+ai+1。</p><p>基于贝茜的信息，帮助约翰恢复可以产生序列 b 的“字典序最小”的排列 a。</p><p>排列 x 字典序小于排列 y，如果对于某个 j，对于所有 i&lt;j 均有 xi=yi，且有 xj&lt;yj（换句话说，这两个排列到某个位置之前都相同，在这个位置上 x 小于 y）。</p><p>保证存在至少一个满足条件的 a。</p><h5 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h5><p>输入的第一行包含一个整数 N。</p><p>第二行包含 N−1 个空格分隔的整数 b1,b2,…,bN−1。</p><h5 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h5><p>输出一行，包含 N 个空格分隔的整数 a1,a2,…,aN。</p><h5 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h5><p>2≤N≤103</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-java">import java.util.*;public class Main {    static int N = 100010;    static int n;    static boolean f = false;    static int[] a = new int[1010];    static int[] b = new int[1010];    static boolean[] m = new boolean[1010];    public static void main(String[] args) {        Scanner inScanner = new Scanner(System.in);        n = inScanner.nextInt();        for(int i = 1; i &lt; n; i ++)            b[i] = inScanner.nextInt();        inScanner.close();        for(int i = 1; i &lt; b[1]; i ++)        {            Arrays.fill(m, false);            m[i] = true;            a[1] = i;            for(int j = 2; j &lt;= n; j ++)            {                int t = b[j - 1] - a[j - 1];                if(t &gt; 0 &amp;&amp; t &lt;= n &amp;&amp; !m[t])                {                    m[t] = true;                    a[j] = t;                    f = true;                }                else                 {                    f = false;                    break;                }            }            if(f)                break;        }        for(int i = 1; i &lt;= n; i ++)            System.out.printf("%d ", a[i]);    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我在哪？</title>
      <link href="2022/02/12/wo-zai-na/"/>
      <url>2022/02/12/wo-zai-na/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p><a href="https://www.acwing.com/problem/content/1462/">1460. 我在哪？ - AcWing题库</a></p><p>农夫约翰出门沿着马路散步，但是他现在发现自己可能迷路了！</p><p>沿路有一排共 N 个农场。</p><p>不幸的是农场并没有编号，这使得约翰难以分辨他在这条路上所处的位置。</p><p>然而，每个农场都沿路设有一个彩色的邮箱，所以约翰希望能够通过查看最近的几个邮箱的颜色来唯一确定他所在的位置。</p><p>每个邮箱的颜色用 A..Z 之间的一个字母来指定，所以沿着道路的 N 个邮箱的序列可以用一个长为 N 的由字母 A..Z 组成的字符串来表示。</p><p>某些邮箱可能会有相同的颜色。</p><p>约翰想要知道最小的 K 的值，使得他查看任意连续 K 个邮箱序列，他都可以唯一确定这一序列在道路上的位置。</p><p>例如，假设沿路的邮箱序列为 ABCDABC 。</p><p>约翰不能令 K=3，因为如果他看到了 ABC，则沿路有两个这一连续颜色序列可能所在的位置。</p><p>最小可行的 K 的值为 K=4，因为如果他查看任意连续 4 个邮箱，那么可得到的连续颜色序列可以唯一确定他在道路上的位置。</p><h5 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h5><p>输入的第一行包含 N，第二行包含一个由 N 个字符组成的字符串，每个字符均在 A..Z 之内。</p><h5 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h5><p>输出一行，包含一个整数，为可以解决农夫约翰的问题的最小 K 值。</p><h5 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h5><p>1≤N≤100</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-java">import java.util.*;public class Main {    static int N = 100010;    static int n, ans;    static String s;    public static boolean check(int t)    {        for(int i = 0; i &lt;= n - t; i ++)        {            for(int j = i + 1; j &lt;= n - t; j ++)            {                boolean f = false;                for(int k = 0; k &lt; t; k ++)                {                    if(s.charAt(i + k) != s.charAt(j + k))                    {                        f = false;                        break;                    }                    f = true;                }                if(f)                    return true;            }        }        return false;    }    public static int work()    {        int l = 1, r = n, mid;        while(l &lt; r)        {            mid = (l + r) &gt;&gt; 1;            if(check(mid))                l = mid + 1;            else                r = mid;        }        return l;    }    public static void main(String[] args) {        Scanner inScanner = new Scanner(System.in);        n = inScanner.nextInt();        s = inScanner.next();        inScanner.close();        System.out.println(work());    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛奶工厂</title>
      <link href="2022/02/11/niu-nai-gong-han/"/>
      <url>2022/02/11/niu-nai-gong-han/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>链接：<a href="https://www.acwing.com/problem/content/1473/">1471. 牛奶工厂 - AcWing题库</a></p><p>牛奶生意正红红火火！</p><p>农夫约翰的牛奶加工厂内有 N 个加工站，编号为 1…N，以及 N−1 条通道，每条连接某两个加工站。（通道建设很昂贵，所以约翰选择使用了最小数量的通道，使得从每个加工站出发都可以到达所有其他加工站）。</p><p>为了创新和提升效率，约翰在每条通道上安装了传送带。</p><p>不幸的是，当他意识到传送带是单向的已经太晚了，现在每条通道只能沿着一个方向通行了！</p><p>所以现在的情况不再是从每个加工站出发都能够到达其他加工站了。</p><p>然而，约翰认为事情可能还不算完全失败，只要至少还存在一个加工站 i 满足从其他每个加工站出发都可以到达加工站 i。</p><p>注意从其他任意一个加工站 j 前往加工站 i 可能会经过 i 和 j 之间的一些中间站点。</p><p>请帮助约翰求出是否存在这样的加工站 i。</p><p>输入格式<br>输入的第一行包含一个整数 N，为加工站的数量。</p><p>以下 N−1行每行包含两个空格分隔的整数 ai 和 bi，满足 1≤ai,bi≤N 以及 ai≠bi。</p><p>这表示有一条从加工站 ai 向加工站 bi 移动的传送带，仅允许沿从 ai 到 bi 的方向移动。</p><p>输出格式<br>如果存在加工站 i 满足可以从任意其他加工站出发都可以到达加工站 i，输出最小的满足条件的 i。</p><p>否则，输出 −1。</p><p>数据范围<br>1≤N≤100</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-java">import java.util.*;public class Main {    static int N = 100010;    static int n, m;    static int[] pre = new int[110];    public static int find(int k)    {        if(pre[k] != -1)        {    pre[k] = find(pre[k]);            return pre[k];        }        return k;    }    public static void main(String[] args) {        Scanner inScanner = new Scanner(System.in);        n = inScanner.nextInt();        Arrays.fill(pre, -1);        int ans = 0;        for(int i = 1; i &lt; n; i ++)        {            int x, y;            x = inScanner.nextInt();            y = inScanner.nextInt();            pre[x] = y;        }        inScanner.close();        for(int i = 1; i &lt;= n; i ++)        {            if(pre[i] == -1)            {                ans = i;                break;            }        }        for(int i = 1; i &lt;= n; i ++)        {            if(i != ans &amp;&amp; find(i) != ans)            {                ans = -1;                break;            }        }        System.out.println(ans);    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大型植被恢复</title>
      <link href="2022/02/10/da-xing-zhi-bei-hui-fu/"/>
      <url>2022/02/10/da-xing-zhi-bei-hui-fu/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>链接：<a href="https://www.acwing.com/problem/content/description/1686/">1684. 大型植被恢复 - AcWing题库</a></p><p>长时间的干旱使得 Farmer John 的 NN 块草地上牧草匮乏。</p><p>随着雨季即将到来，现在应当是重新种植的时候了。</p><p>在 Farmer John 的储物棚里有四个桶，每个桶里装着一种不同的草种。</p><p>他想要在每块草地上播种其中一种草。</p><p>作为一名奶农，Farmer John 想要确保他的每头奶牛都能得到丰富的食谱。</p><p>他的 MM 头奶牛每一头都有两块喜爱的草地，他想要确保这两块草地种植不同种类的草，从而每头奶牛都可以选择两种草。</p><p>已知每块草地最多被 44 头奶牛喜爱。</p><p>请帮助 Farmer John 选择每块草地所种的草的种类，使得所有奶牛的营养需求都得到满足。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入的第一行包含 NN 和 MM。</p><p>以下 MM 行，每行包含两个范围为 1…N1…N 的整数，为 Farmer John 的一头奶牛喜欢的两块草地。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个 NN 位数，每一位均为 1…41…4 之一，表示每一块草地上所种的草的种类。</p><p>第一位对应草地 11 的草的种类，第二位对应草地 22，以此类推。</p><p>如果有多种可行的解，只需输出所有解中最小的 NN 位数。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>2≤N≤1002≤N≤100,<br>1≤M≤150</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-java">import java.util.*;public class Main {    static int N = 100010;    static int n, m;    static int[][] a = new int[110][110];    static int[] ans = new int[110];    static boolean[] f = new boolean[5];    public static void main(String[] args) {        Scanner inScanner = new Scanner(System.in);        n = inScanner.nextInt();        m = inScanner.nextInt();        for(int i = 1; i &lt;= m; i ++)        {            int x, y;            x = inScanner.nextInt();            y = inScanner.nextInt();            a[x][y] = 1;            a[y][x] = 1;        }        for(int i = 1; i &lt;= n; i ++)        {            Arrays.fill(f, false);            for(int j = 1; j &lt;= n; j ++)            {                if(a[i][j] == 1)                    f[ans[j]] = true;            }            for(int j = 1; j &lt;= 4; j ++)            {                if(!f[j])                {                    ans[i] = j;                    break;                }            }        }        for(int i = 1; i &lt;= n; i ++)            System.out.print(ans[i]);    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>困牛排序</title>
      <link href="2022/02/09/kun-niu-pai-xu/"/>
      <url>2022/02/09/kun-niu-pai-xu/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>链接：<a href="https://www.acwing.com/problem/content/1698/">1696. 困牛排序 - AcWing题库</a></p><p>Farmer John 正在尝试将他的 N 头奶牛，方便起见编号为 1…N，在她们前往牧草地吃早餐之前排好顺序。</p><p>当前，这些奶牛以 p1,p2,p3,…,pN 的顺序排成一行，Farmer John 站在奶牛 p1 前面。</p><p>他想要重新排列这些奶牛，使得她们的顺序变为 1,2,3,…,N，奶牛 1 在 Farmer John 旁边。</p><p>今天奶牛们有些困倦，所以任何时刻都只有直接面向 Farmer John 的奶牛会注意听 Farmer John 的指令。</p><p>每一次他可以命令这头奶牛沿着队伍向后移动 k 步，k 可以是范围 1…N−1 中的任意数。</p><p>她经过的 k 头奶牛会向前移动，腾出空间使得她能够插入到队伍中这些奶牛之后的位置。</p><p>例如，假设 N=4，奶牛们开始时是这样的顺序：</p><p>FJ: 4, 3, 2, 1</p><p>唯一注意 FJ 指令的奶牛是奶牛 4。</p><p>当他命令她向队伍后移动 2 步之后，队伍的顺序会变成：</p><p>FJ: 3, 2, 4, 1</p><p>现在唯一注意 FJ 指令的奶牛是奶牛 3，所以第二次他可以给奶牛 3 下命令，如此进行直到奶牛们排好了顺序。</p><p>Farmer John 急欲完成排序，这样他就可以回到他的农舍里享用他自己的早餐了。</p><p>请帮助他求出将奶牛们排好顺序所需要的最小操作次数。</p><p>输入格式<br>输入的第一行包含 N。</p><p>第二行包含 N 个空格分隔的整数，p1,p2,p3,…,pN，表示奶牛们的起始顺序。</p><p>输出格式<br>输出一个整数，为 Farmer John 采用最佳策略可以将这 N 头奶牛排好顺序所需要的操作次数。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-java">import java.util.*;public class Main {    static int N = 100010;    static int n;    static int[] a = new int[110];    public static void main(String[] args) {        Scanner inScanner = new Scanner(System.in);        n = inScanner.nextInt();        for(int i = 1; i &lt;= n; i ++)            a[i] = inScanner.nextInt();        int cnt = 0;        a[n + 1] = 1000;        for(int i = n; i &gt; 0; i --)        {            if(a[i] &gt; a[i + 1])                break;            cnt ++;        }        inScanner.close();        System.out.println(n - cnt);    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>桶列表</title>
      <link href="2022/02/08/tong-lie-biao/"/>
      <url>2022/02/08/tong-lie-biao/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>链接：<a href="https://www.acwing.com/problem/content/1717/">1715. 桶列表 - AcWing题库</a></p><p>Farmer John 正在考虑改变他给奶牛挤奶的时候分配牛奶桶的方式。</p><p>他认为这最终能使得他使用数量更少的桶，然而他不清楚具体是多少，请帮助他！</p><p>Farmer John 有 N 头奶牛，方便起见编号为 1…N。</p><p>第 i 头奶牛需要从时刻 si 到时刻 ti 之间挤奶，并且挤奶过程中需要用到 bi 个桶。</p><p>多头奶牛可能在同一时刻都在挤奶；每个桶在每个时刻只能供一头奶牛使用。</p><p>也就是说，第 i 头奶牛在时刻 si 到时刻 ti 之间挤奶时，如果用到了某个桶，则该桶在这段时间不能被其他奶牛使用。</p><p>当然，这个桶在这段时间之外可以被其他奶牛所使用。</p><p>为了简化他的工作，FJ 保证在任一时刻，至多只有一头奶牛开始或是结束挤奶（也就是说，所有的 si 和 ti 各不相同）。</p><p>FJ 有一个储藏室，里面有依次编号为 1、2、3、…… 的桶。</p><p>在他的挤奶策略中，当某一头奶牛（比如说，奶牛 i）开始挤奶（在时刻 si），FJ 就跑到储藏室取出编号最小的 bi 个桶分配给第 i 头奶牛用来挤奶。</p><p>请求出 FJ 需要在储藏室中存放多少个桶才能使得他能够顺利地给所有奶牛挤奶。</p><p>输入格式<br>输入的第一行包含 N。</p><p>以下 N 行，每行描述了一头奶牛，包含三个空格分隔的数 si,ti,bi。</p><p>其中 si 和 ti 均为 1…1000 之间的整数，bi 为 1…10 之间的整数。</p><p>输出格式<br>输出一个整数，为 FJ 需要的桶的数量。</p><p>数据范围<br>1≤N≤100</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-java">import java.util.*;public class Main {    static int N = 100010;    static int n, ans = 0;    static int[] a = new int[1100];    public static void main(String[] args) {        Scanner inScanner = new Scanner(System.in);        n = inScanner.nextInt();        for(int i = 1; i &lt;= n; i ++)        {            int s, t, b;            s = inScanner.nextInt();            t = inScanner.nextInt();            b = inScanner.nextInt();            a[s] += b;            a[t + 1] -= b;        }        inScanner.close();        int sum = 0;        for(int i = 1; i &lt;= 1001; i ++)        {            sum += a[i];            ans = sum &gt; ans ? sum : ans;        }        System.out.println(ans);    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>挤奶顺序</title>
      <link href="2022/02/07/ji-nai-shun-xu/"/>
      <url>2022/02/07/ji-nai-shun-xu/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>链接：<a href="https://www.acwing.com/problem/content/description/1728/">1726. 挤奶顺序 - AcWing题库</a></p><p>Farmer John 有 N 头奶牛，编号为 1…N。</p><p>他每天都要给他的奶牛们挤奶。</p><p>奶牛的社会结构非常复杂，其结构有两个关键特性。</p><p>首先，有 M 头奶牛的地位等级分明，按照地位越高越早挤奶的规则，这些奶牛的相对挤奶顺序是固定的。</p><p>此外，有 K 头奶牛的具体挤奶顺序也是固定的，比方说，奶牛 4 必须在所有奶牛中的第二位挤奶。</p><p>幸运的是，Farmer John 总是能够以一种满足所有这些情况的顺序给他的奶牛们挤奶。</p><p>不幸的是，奶牛 1 最近生病了，所以 Farmer John 想要尽早给这头奶牛挤奶，使得她可以回到牛棚获得急需的休息。</p><p>请帮助 Farmer John 求出奶牛 1 可以在挤奶顺序中出现的最早位置。</p><p>输入格式<br>第一行包含 N，M，K，表示 Farmer John 有 N 头奶牛，其中 M 头形成了社会阶层，K 头需要在挤奶顺序中处于一个特定的位置。</p><p>下一行包含 M 个不同的整数 mi。在这一行出现的奶牛必须以与她们在这行出现的顺序相同的顺序进行挤奶。</p><p>下面 K 行，每行包含两个整数 ci 和 pi，表示奶牛 ci 一定要在第 pi 位进行挤奶。</p><p>输入数据保证在这些限制之下，Farmer John 能够建立一个符合要求的挤奶顺序。</p><p>输出格式<br>输出奶牛 1 可以在挤奶顺序中出现的最早位置。</p><p>数据范围<br>2≤N≤100,<br>1≤M,K&lt;N,<br>1≤mi,ci,pi≤N</p><pre><code class="lang-java">import java.util.*;public class Main {    static int N = 100010;    static int n, m, k;    static int[] a = new int[110];    static int[] c = new int[110];    static int[] f = new int[110];    public static void work(int l, int r, int q)    {        while(r &gt;= l)        {            if(c[q] == -1)            {                c[q] = a[r];                r --;            }            q --;        }    }    public static void main(String[] args) {        Scanner inScanner = new Scanner(System.in);        n = inScanner.nextInt();        m = inScanner.nextInt();        k = inScanner.nextInt();        boolean t = false;        Arrays.fill(c, -1);        for(int i = 1; i &lt;= m; i ++)        {            a[i] = inScanner.nextInt();            if(a[i] == 1)                t = true;        }        for(int i = 1; i &lt;= k; i ++)        {            int ci, pi;            ci = inScanner.nextInt();            pi = inScanner.nextInt();            c[pi] = ci;            f[ci] = pi;        }        int pre = 0;        for(int i = 1; i &lt;= m; i ++)        {            if(f[a[i]] != 0)            {                work(pre + 1, i - 1, f[a[i]] - 1);                pre = i;            }        }        inScanner.close();        if(t)        {            int j = f[a[pre]] + 1;            int i = pre + 1;            while(i &lt;= m &amp;&amp; j &lt;= n)            {                if(c[j] == -1)                {                    c[j] = a[i];                    i ++;                }                j ++;            }            for(i = 1; i &lt;= n; i ++)            {                if(c[i] == 1)                {                    System.out.println(i);                    break;                }            }        }        else        {            for(int i = 1; i &lt;= n; i ++)            {                if(c[i] == -1)                {                    System.out.println(i);                    break;                }            }        }    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蹄球</title>
      <link href="2022/02/05/ti-qiu/"/>
      <url>2022/02/05/ti-qiu/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>链接：<a href="https://www.acwing.com/problem/content/description/1740/">1738. 蹄球 - AcWing题库</a></p><p>为了准备即将到来的蹄球锦标赛，Farmer John 正在训练他的 N 头奶牛（方便起见，编号为 1…N）进行传球。</p><p>这些奶牛在牛棚一侧沿直线排列，第 i 号奶牛位于距离牛棚 xi 的地方。</p><p>每头奶牛都在不同的位置上。</p><p>在训练开始的时候，Farmer John 会将若干个球传给不同的奶牛。</p><p>当第 i 号奶牛接到球时，无论是从 Farmer John 或是从另一头奶牛传来的，她会将球传给最近的奶牛（如果有多头奶牛与她距离相同，她会将球传给这些奶牛中最左边的那头奶牛。）。</p><p>为了使所有奶牛都有机会练习到传球，Farmer John 想要确保每头奶牛都持球至少一次。</p><p>帮助他求出为了达到这一目的他开始时至少要传出的球的数量。</p><p>假设他在开始的时候能将球传给最适当的一组奶牛。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-java">import java.util.*;public class Main {    static int N = 100010;    static int n, ans = 0;    static int[] a = new int[110];    static int[] b = new int[110];    public static void main(String[] args) {        Scanner inScanner = new Scanner(System.in);        n = inScanner.nextInt();        for(int i = 1; i &lt;= n; i ++)            a[i] = inScanner.nextInt();        Arrays.sort(a, 1, n + 1);        for(int i = 1; i &lt; n; i ++)            a[i] = a[i + 1] - a[i];        for(int i = 2; i &lt; n; i ++)            b[i] = a[i] &gt;= a[i - 1] ? 1 : -1;        b[1] = -1;        b[n] = 1;        for(int i = 1; i &lt; n; i ++)            if(b[i] &lt; 0 &amp;&amp; b[i + 1] &gt; 0)            {                ans ++;                if(b[i - 1] &lt; 0 &amp;&amp; b [i + 2] &gt; 0)                    ans ++;            }        System.out.println(ans);        inScanner.close();    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>救生员</title>
      <link href="2022/02/04/jiu-sheng-yuan/"/>
      <url>2022/02/04/jiu-sheng-yuan/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>链接：<a href="https://www.acwing.com/problem/content/1752/">1750. 救生员 - AcWing题库</a></p><p>农夫约翰为他的牛开设了一个游泳池，他认为这将帮助它们放松并产出更多的奶。</p><p>为了确保安全，他雇佣了 N 头奶牛作为救生员，每头奶牛的工作班次都是一段连续的时间。</p><p>为了简单起见，游泳池每天的开放时间从时刻 0 到时刻 1000。</p><p>每个奶牛的工作班次都可以用两个整数来描述，它们分别表示该奶牛工作班次的开始时刻和结束时刻。</p><p>例如，从时刻 t=4 开始工作并在时刻 t=7 结束工作的救生员，它的工作时间为三个时间单位（请注意，时间“段”两端的端点是时间轴上的“点”）。</p><p>不幸的是，由于资金紧张问题，约翰不得不解雇一头奶牛。</p><p>请问通过合理裁员，剩余救生员的工作班次仍然可以覆盖的最大时间有多长？</p><p>一个时间间隔内如果存在至少一名救生员当值，那么这个时间间隔就认为是被覆盖的。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-java">import java.util.*;public class Main {    static int N = 100010;    static int n, ans = 0;    static boolean[] f = new boolean[1010];    static node[] a = new node[110];    public static void main(String[] args) {        Scanner inScanner = new Scanner(System.in);        n = inScanner.nextInt();        for(int i = 0; i &lt; n; i ++)            a[i] = new node(inScanner.nextInt(), inScanner.nextInt());        for(int i = 0; i &lt; n; i ++)        {            Arrays.fill(f, false);            int sum = 0;            for(int j = 0; j &lt; n; j ++)            {                if(i != j)                {                    int l = a[j].l;                    int r = a[j].r;                    while(l &lt; r)                    {                        if(!f[l])                        {                            f[l] = true;                            sum ++;                        }                        l ++;                    }                }            }            ans = sum &gt; ans ? sum : ans;        }        System.out.println(ans);        inScanner.close();    }}class node{    int l, r;    public node(int l, int r)    {        this.l = l;        this.r = r;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛的洗牌</title>
      <link href="2022/02/03/niu-de-xi-pai/"/>
      <url>2022/02/03/niu-de-xi-pai/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>链接：<a href="https://www.acwing.com/problem/content/1764/">1762. 牛的洗牌 - AcWing题库</a></p><p>农夫约翰坚信快乐的奶牛会产出更多的牛奶，因此他在谷仓中安装了一个巨大的迪斯科球，并计划教他的奶牛跳舞！</p><p>在查阅了一些牛的流行舞蹈后，约翰决定教他的奶牛“洗牌舞”。</p><p>洗牌舞是由他的 N 只奶牛按一定顺序排成一行，然后连续执行三次“洗牌”，每次“洗牌”都可能会使奶牛重新排序。</p><p>为了让奶牛们更容易找到自己所处的位置，约翰用数字 1∼N 对一行中奶牛所在的位置进行了标记，一行中第一头奶牛处于位置 1，第二头奶牛处于位置 2，以此类推，直到位置 N。</p><p>每次“洗牌”用 N 个数字 $a_1,a_2,…,a_N$ 来描述，处于位置 i 的奶牛在一次“洗牌”过后，需要移动至位置 $a_i$（因此，每个 $a_i$ 在 1…N 范围内）。</p><p>幸运的是，所有 $a_i$ 都是互不相同的，因此，不会存在多头奶牛在洗牌结束后移动到同一个位置的情况。</p><p>约翰的每头奶牛都有一个属于自己的唯一 7 位整数 ID （不含前导 0）。</p><p>给定你三轮“洗牌”过后的奶牛排列顺序，请你求出奶牛们的初始排列顺序。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-java">import java.util.*;public class Main {    static int N = 100010;    static int n;    static TreeMap&lt;Integer, Integer&gt; m = new TreeMap&lt;Integer, Integer&gt;();    static int[] b = new int[1000];    public static void main(String[] args) {        Scanner inScanner = new Scanner(System.in);        n = inScanner.nextInt();        for(int i = 1; i &lt;= n; i ++)            m.put(inScanner.nextInt(), i);        for(int i = 1; i &lt;= n; i ++)        {            int k = i;            int j = 3;            while(j --&gt; 0)                k = m.get(k);            b[k] = inScanner.nextInt();        }        for(int i = 1; i &lt;= n; i ++)            System.out.println(b[i]);        inScanner.close();    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛的基因组学</title>
      <link href="2022/02/03/niu-de-ji-yin-zu-xue/"/>
      <url>2022/02/03/niu-de-ji-yin-zu-xue/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>链接：<a href="https://www.acwing.com/problem/content/1778/">1776. 牛的基因组学 - AcWing题库</a></p><p>农夫约翰拥有 N 头有斑点的牛和 N 头没有斑点的牛。</p><p>他刚刚完成了牛遗传学课程，他确信奶牛上的斑点是由牛基因组突变引起的。</p><p>农夫约翰花了大价钱对他的奶牛的基因组进行了测序。</p><p>每个基因组都是一个由四个字符 A,C,G,T 构成的长度为 M 的字符串。</p><p>当他统计得到的奶牛的基因组序列时，可以得到一个如下所示的表：（此时，N=3）</p><pre><code class="lang-html">位置 :    1 2 3 4 5 6 7 ... M斑点牛 1: A A T C C C A ... T斑点牛 2: G A T T G C A ... A斑点牛 3: G G T C G C A ... A普通牛 1: A C T C C C A ... G普通牛 2: A C T C G C A ... T普通牛 3: A C T T C C A ... T</code></pre><p>通过仔细观察该表，他发现通过位置 2 的字符足以判断奶牛是否存在斑点。</p><p>也就是说，仅通过查看这个位置上的字符，农夫约翰就可以判断他的哪些奶牛有斑点，哪些没有斑点。（在这里，A 和 G 表示有斑点，C 表示无斑点，T 无关紧要，因为没有任何一头牛的第二个位置上的字符是 T）</p><p>位置 1 上的字符不足以判断奶牛是否存在斑点，因为 A 既可以表示有斑点也可以表示无斑点。</p><p>给定约翰的奶牛的基因组序列列表，请你计算可以单独用来判断奶牛是否存在斑点的位置的数量。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-java">import java.util.*;public class Main {    static int N = 100010;    static int n, m, ans = 0;    static String[] q = new String[110];    static TreeSet&lt;Integer&gt;[] set = new TreeSet[110];    public static boolean check(int k)    {        for(int i = 1; i &lt;= n; i ++)        {            int t = q[i].charAt(k) - 'A';            if(set[k].contains(t))                return false;        }        return true;    }    public static void main(String[] args) {        Scanner inScanner = new Scanner(System.in);        n = inScanner.nextInt();        m = inScanner.nextInt();        String s;        for(int i = 0; i &lt; m; i ++)            set[i] = new TreeSet&lt;Integer&gt;();        for(int i = 1; i &lt;= n; i ++)        {            s = inScanner.next();            for(int j = 0; j &lt; m; j ++)                set[j].add(s.charAt(j) - 'A');        }        for(int i = 1; i &lt;= n; i ++)            q[i] = inScanner.next();        for(int i = 0; i &lt; m; i ++)        {            if(check(i))                ans ++;        }        inScanner.close();        System.out.println(ans);    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛为什么过马路II</title>
      <link href="2022/02/03/niu-wei-shi-me-guo-ma-lu-ii/"/>
      <url>2022/02/03/niu-wei-shi-me-guo-ma-lu-ii/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>链接：<a href="https://www.acwing.com/problem/content/1791/">1789. 牛为什么过马路 II - AcWing题库</a></p><p>农夫约翰的农场布局十分奇特，一条大型的环形道路将奶牛吃草的田地围了起来。</p><p>每天早晨，奶牛们穿过这条道路，进入到田地吃草；每天晚上，奶牛们穿过这条道路，离开田地，返回牛棚休息。</p><p>众所周知，奶牛是有习性的动物，每头奶牛每天通过道路的方式都相同。</p><p>每头奶牛每天固定地从道路的某一位置进入田地，从道路的另一不同位置离开田地。</p><p>所有奶牛的所有进出位置之间互不相同。</p><p>约翰共有 26 头奶牛，依次命名为 A∼Z。</p><p>因此，道路上共有 52 个不同的进出位置。</p><p>约翰沿着环形道路按顺时针方向扫描了每个位置，并记录了每个位置处经过的奶牛的名字，最终形成了一个包含 52 个字母的序列，A∼Z 中的每个字母恰好出现两次。</p><p>他并没有记录哪些位置是入口，哪些位置是出口。</p><p>看着地图上记录的这些位置，约翰想要知道一天当中，有多少对奶牛之间的从入口穿过田地到达出口的路径可能会存在交叉。</p><p>如果奶牛 A 从入口穿过田地到达出口的路径必须穿过奶牛 B 从入口穿过田地到达出口的路径，那么称这对牛 (A,B) 是“交叉”对。</p><p>请帮助约翰计算“交叉”对（不考虑顺序，即 (A,B) 与 (B,A) 视为同一对 ）的总数。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-java">import java.util.*;public class Main {    static int N = 100010;    static int n, ans = 0, cnt = 0;    static String s;    static int[] a = new int[26];    static int[] sum = new int[60];    public static void main(String[] args) {        Scanner inScanner = new Scanner(System.in);        s = inScanner.next();        n = s.length();        for(int i = 0; i &lt; n - 1; i ++)        {            for(int j = i + 1; j &lt; n; j ++)            {                if(s.charAt(i) == s.charAt(j))                {                    ans += cnt;                    break;                }                else                 {                    int t = s.charAt(j) - 'A';                    a[t] ++;                    if(a[t] == 1)                        cnt ++;                    else                        cnt --;                }            }            Arrays.fill(a, 0);            cnt = 0;        }        inScanner.close();        System.out.println(ans / 2);    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蹄子剪刀布</title>
      <link href="2022/01/29/ti-zi-jian-dao-bu/"/>
      <url>2022/01/29/ti-zi-jian-dao-bu/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>链接：<a href="https://www.acwing.com/problem/content/1803/">1801. 蹄子剪刀布 - AcWing题库</a></p><p>你可能听说过“石头剪刀布”的游戏。</p><p>这个游戏在牛当中同样流行，它们称之为“蹄子剪刀布”。</p><p>游戏的规则非常简单，两头牛相互对抗，数到三之后各出一个表示蹄子，剪刀或布的手势。</p><p>蹄子赢剪刀，剪刀赢布，布赢蹄子。</p><p>例如，第一头牛出“蹄子”手势，第二头牛出“布”手势，则第二头牛获胜。</p><p>如果两头牛出相同的手势，则算平局。</p><p>农夫约翰的两头奶牛正在进行 N 轮“蹄子剪刀布”对抗，他看的十分入迷。</p><p>不幸的是，虽然他可以看到奶牛正在做出三种不同类型的手势，但他却无法分辨出哪一个代表“蹄子”，哪一个代表“布”以及哪一个代表“剪刀”。</p><p>不知道这三种手势的具体含义的情况下，农夫约翰给这三种手势分配了编号 1,2,3。</p><p>手势 1 可能代表“蹄子”，可能代表“剪刀”，也可能代表“布”，反正他傻傻分不清楚。</p><p>给出两头奶牛在 N 场比赛中所做出的具体手势对应的编号，请你判断第一头奶牛最多可能赢多少盘对抗。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-java">import java.util.*;public class Main {    static int N = 100010;    static int n;    public static void main(String[] args) {        Scanner inScanner = new Scanner(System.in);        n = inScanner.nextInt();        int a = 0, b = 0;        while(n --&gt; 0)        {            int x, y;            x = inScanner.nextInt();            y = inScanner.nextInt();            x --;             y --;            if((x + 1) % 3 == y)                a ++;            if((y + 1) % 3 == x)                b ++;        }        inScanner.close();        System.out.printf("%d\n", Math.max(a, b));    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>方块游戏</title>
      <link href="2022/01/28/fang-kuai-you-xi/"/>
      <url>2022/01/28/fang-kuai-you-xi/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>链接：<a href="https://www.acwing.com/problem/content/1815/">1813. 方块游戏 - AcWing题库</a></p><p>农夫约翰试图通过给奶牛一套通常用于学龄前儿童的 <code>N</code> 个拼写板来教他的奶牛阅读。</p><p>每个拼写板的每一侧都有一个单词和一个图画。</p><p>例如，一侧可能有单词 <code>cat</code> 和一只小猫，另一侧可能有单词 <code>dog</code> 和一只小狗。</p><p>因此，当所有拼写板放置到地面上时，会显示一组 <code>N</code> 个单词。</p><p>通过翻转其中一部分板子，就可以得到另一组 <code>N</code> 个单词。</p><p>为了帮助奶牛练习单词拼写，约翰想要制作一些木块，在每个木块上都印上一个字母，使得奶牛可以使用这些木块拼出看到的单词。</p><p>为了使得无论哪一组 <code>N</code> 个单词朝上显示，奶牛都能将其全部拼出，就需要印有各种字母的木块都足够的多。</p><p>例如，如果 <code>N=3</code> 且单词 <code>box,cat,car</code> 朝上显示，则奶牛至少需要一个 <code>b</code> 块，一个 <code>o</code> 块，一个 <code>x</code> 块，两个 <code>c</code> 块，两个 <code>a</code> 块，一个 <code>t</code> 块和一个 <code>r</code> 块。</p><p>请帮助约翰确定，印有每种字母的木块至少需要提供多少块，才能使得不管每个板子的哪一侧朝上显示，奶牛都可以拼出所有 <code>N</code> 个可见的单词。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-java">import java.util.*;public class Main {    static int N = 100010;    static int n;    static int[] ans = new int[26];    static int[] sum = new int[26];    static int[] sum1 = new int[26];    public static void main(String[] args) {        Scanner inScanner = new Scanner(System.in);        n = inScanner.nextInt();        String a;        for(int i = 1; i &lt;= n; i ++)        {            a = inScanner.next();            for(int j = 0; j &lt; a.length(); j ++)                sum[a.charAt(j) - 'a'] ++;            a = inScanner.next();            for(int j = 0; j &lt; a.length(); j ++)                sum1[a.charAt(j) - 'a'] ++;            for(int j = 0; j &lt; 26; j ++)            {                ans[j] += Math.max(sum[j], sum1[j]);                sum[j] = sum1[j] = 0;            }        }        inScanner.close();        for(int i = 0; i &lt; 26; i ++)            System.out.printf("%d\n", ans[i]);    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>农田缩减</title>
      <link href="2022/01/27/nong-tian-suo-jian/"/>
      <url>2022/01/27/nong-tian-suo-jian/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>链接：<a href="https://www.acwing.com/problem/content/1828/">1826. 农田缩减 - AcWing题库</a></p><p>农夫约翰的 <code>N</code> 头奶牛分布在其二维农场的不同位置。</p><p>约翰想用一个长方形的围栏把所有的奶牛围起来，围栏的边需要平行于 <code>x</code> 轴和 <code>y</code> 轴。</p><p>在能够包含所有奶牛的情况下（处于围栏边界的奶牛也算包含在内），约翰希望围栏围起的面积尽可能小。</p><p>不幸的是，由于上个季度的牛奶产量很低，约翰的预算十分紧张。</p><p>因此，他希望建立一个更小的围栏，甚至为了实现这一目标，他愿意卖掉农场中的一头奶牛。</p><p>请帮助约翰计算，卖掉牛群中的一头奶牛以后，他可以用围栏围起来的最小面积（为剩下的奶牛建造尽可能小的围栏）。</p><p>对于这个问题，请将奶牛视为点，将围栏视为四个线段的集合。</p><p>注意，答案可以是零，例如，所有剩余的奶牛最终都站在同一条垂直或水平线上。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-java">import java.util.*;public class Main {    static int N = 100010;    static int n, x, y;    static node min_x, premin_x;    static node max_x, premax_x;    static node min_y, premin_y;    static node max_y, premax_y;    public static void minx(int x, int key)    {        if(x &lt; min_x.v)        {            premin_x.key = min_x.key;            premin_x.v = min_x.v;            min_x.key = key;            min_x.v = x;        }        else if(x &lt; premin_x.v)        {            premin_x.key = key;            premin_x.v = x;        }    }    public static void maxx(int x, int key)    {        if(x &gt; max_x.v)        {            premax_x.key = max_x.key;            premax_x.v = max_x.v;            max_x.key = key;            max_x.v = x;        }        else if(x &gt; premax_x.v)        {            premax_x.key = key;            premax_x.v = x;        }    }    public static void miny(int y, int key)    {        if(y &lt; min_y.v)        {            premin_y.key = min_y.key;            premin_y.v = min_y.v;            min_y.key = key;            min_y.v = y;        }        else if(y &lt; premin_y.v)        {            premin_y.key = key;            premin_y.v = y;        }    }    public static void maxy(int y, int key)    {        if(y &gt; max_y.v)        {            premax_y.key = max_y.key;            premax_y.v = max_y.v;            max_y.key = key;            max_y.v = y;        }        else if(y &gt; premax_y.v)        {            premax_y.key = key;            premax_y.v = y;        }    }    public static void main(String[] args) {        Scanner inScanner = new Scanner(System.in);        n = inScanner.nextInt();        min_x = new node(0, Integer.MAX_VALUE);        premin_x = new node(0, Integer.MAX_VALUE);        min_y = new node(0, Integer.MAX_VALUE);        premin_y = new node(0, Integer.MAX_VALUE);        max_x = new node(0, Integer.MIN_VALUE);        premax_x = new node(0, Integer.MIN_VALUE);        max_y = new node(0, Integer.MIN_VALUE);        premax_y = new node(0, Integer.MIN_VALUE);        for(int i = 1; i &lt;= n; i ++)        {            x = inScanner.nextInt();            y = inScanner.nextInt();            minx(x, i);            miny(y, i);            maxx(x, i);            maxy(y, i);        }        inScanner.close();        int lx = premin_x.v - min_x.v;        int rx = max_x.v - premax_x.v;        int ly = premin_y.v - min_y.v;        int ry = max_y.v - premax_y.v;        if(lx &gt;= rx &amp;&amp; lx &gt;= ly &amp;&amp; lx &gt;= ry)        {            if(min_x.key == min_y.key)                min_y.v = premin_y.v;            else if(min_x.key == max_y.key)                max_y.v = premax_y.v;            min_x.v = premin_x.v;        }        else if(rx &gt;= lx &amp;&amp; rx &gt;= ly &amp;&amp; rx &gt;= ry)        {            if(max_x.key == min_y.key)                min_y.v = premin_y.v;            else if(max_x.key == max_y.key)                max_y.v = premax_y.v;            max_x.v = premax_x.v;        }        else if(ly &gt;= lx &amp;&amp; ly &gt;= rx &amp;&amp; ly &gt;= ry)        {            if(min_y.key == min_x.key)                min_x.v = premin_x.v;            else if(min_y.key == max_x.key)                max_x.v = premax_x.v;            min_y.v = premin_y.v;        }        else        {            if(max_y.key == min_x.key)                min_x.v = premin_x.v;            else if(max_y.key == max_x.key)                max_x.v = premax_x.v;            max_y.v = premax_y.v;        }        System.out.println((max_x.v - min_x.v) * (max_y.v - min_y.v));    }}class node{    int v, key;    public node(int key, int v)    {        this.v = v;        this.key = key;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>圆形牛棚</title>
      <link href="2022/01/26/yuan-xing-niu-peng/"/>
      <url>2022/01/26/yuan-xing-niu-peng/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>链接：<a href="https://www.acwing.com/problem/content/1845/">1843. 圆形牛棚 - AcWing题库</a></p><p>作为当代建筑的爱好者，农夫约翰建造了一个完美圆环形状的新牛棚。</p><p>牛棚内部有 <code>n</code> 个房间，围成一个环形，按顺时针编号为 <code>1∼n</code>。</p><p>每个房间都既有通向相邻两个房间的门，也有通向牛棚外部的门。</p><p>约翰想让第 <code>i</code> 个房间内恰好有 <code>ri</code> 头牛。</p><p>为了让奶牛们有序的进入牛棚，他计划打开一个外门，让牛从该门进入。</p><p>然后，每头牛顺时针穿过房间，直到到达合适的房间为止。</p><p>约翰希望通过合理选择打开的门，使得所有奶牛的行走距离之和尽可能小（这里只考虑每头牛进入牛棚以后的行走距离）。</p><p>请确定他的奶牛需要行走的最小总距离。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-java">import java.util.*;public class Main {    static int N = 100010;    static int n, ans = Integer.MAX_VALUE;    static int[] a = new int[1010];    public static void main(String[] args) {        Scanner inScanner = new Scanner(System.in);        n = inScanner.nextInt();        for(int i = 0; i &lt; n; i ++)            a[i] = inScanner.nextInt();        inScanner.close();        for(int i = 0; i &lt; n; i ++)        {            int sum = 0;            for(int j = 1; j &lt; n; j ++)                sum += j * a[(i + j) % n];            ans = Math.min(sum, ans);        }        System.out.println(ans);    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>愤怒的奶牛</title>
      <link href="2022/01/25/fen-nu-de-niu/"/>
      <url>2022/01/25/fen-nu-de-niu/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>链接：<a href="https://www.acwing.com/problem/content/1857/">1855. 愤怒的奶牛 - AcWing题库</a></p><p>奶牛贝茜设计了一款她认为必火的游戏：愤怒的奶牛。</p><p>游戏设定（她坚信这是她的原创）是玩家用一个弹弓将一头奶牛射向一个数轴，数轴的不同位置上分布着一些干草捆。</p><p>奶牛以足够的力量砸向某个干草捆，并使得该干草捆发生爆炸，爆炸可能会不断引起连锁反应，导致更多的干草捆发生爆炸。</p><p>目标是用一头奶牛引起的连锁反应引爆尽可能多的干草捆。</p><p>共有 <code>N</code> 个干草捆位于数轴中的不同整数位置，其坐标依次为 <code>x1,x2,…,xN</code>。</p><p>如果将奶牛射向位于位置 <code>x</code> 的干草捆，则该干草捆发生爆炸，爆炸半径为 <code>1</code>，爆炸将吞噬 1 单位距离内的所有干草捆。</p><p>然后这些干草捆（全部同时）发生爆炸，每个干草捆的爆炸半径为 <code>2</code>。</p><p>二次爆炸中吞噬的所有尚未爆炸的干草捆也（全部同时）发生爆炸，爆炸半径为 <code>3</code>。</p><p>也就是说，在 t 时刻爆炸的干草捆的爆炸半径为 <code>t</code>，其爆炸波及的干草捆在 <code>t+1</code> 时刻也会爆炸，爆炸半径为 <code>t+1</code>，以此类推。</p><p>请确定，通过合理选择奶牛射向的干草捆，能够引爆的干草捆最大数量。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-java">import java.util.*;public class Main {    static int N = 100010;    static int n, ans = 0;    static int[] a = new int[110];    public static int bfsl(int i, int len)    {        if(i &lt;= 1)            return 0;        int tl = 0 ;        int j = i - 1 ;        while(j &gt; 0&amp;&amp; a[i] - a[j] &lt;= len)        {            j --;            tl ++;        }        if(tl == 0)            return 0;        tl += bfsl(j + 1, len + 1);        return tl;    }    public static int bfsr(int i, int len)    {        if(i &gt;= n)            return 0;        int tr = 0 ;        int j = i + 1 ;        while(j &lt;= n&amp;&amp; a[j] - a[i] &lt;= len)        {            j ++;            tr ++;        }        if(tr == 0)            return 0;        tr += bfsr(j - 1, len + 1);        return tr;    }    public static void main(String[] args) {        Scanner inScanner = new Scanner(System.in);        n = inScanner.nextInt();        for(int i = 1; i &lt;= n; i ++)            a[i] = inScanner.nextInt();        inScanner.close();        Arrays.sort(a, 1, n + 1);        for(int i = 1; i &lt;= n; i ++)        {            int l = bfsl(i, 1);            int r = bfsr(i, 1);            ans = Math.max(ans, l + r + 1);        }        System.out.println(ans);    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贝茜的报复</title>
      <link href="2022/01/25/bei-qian-de-bao-fu/"/>
      <url>2022/01/25/bei-qian-de-bao-fu/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>链接：<a href="https://www.acwing.com/problem/content/1877/">1875. 贝茜的报复 - AcWing题库</a></p><p>农夫约翰和奶牛贝茜喜欢在业余时间互相出数学题。</p><p>约翰给贝茜出了一道相当难的问题，导致她没能解决。</p><p>现在，她希望通过给约翰出一道有挑战性的难题来报复他。</p><p>贝茜给了约翰一个表达式 <code>(B+E+S+S+I+E)(G+O+E+S)(M+O+O)</code>，其中包含七个变量 <code>B,E,S,I,G,O,M</code>（<code>O</code>是变量，不是零）。</p><p>对于每个变量，她给约翰一个列表，表中包含该变量可采用的最多 <code>20</code> 个整数值。</p><p>她要求约翰计算，共有多少种给变量赋值的方法可以使得表达式的计算结果为偶数。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-java">import java.util.*;public class Main {    static int N = 100010;    static int n;    static Map&lt;String, Integer&gt;[] m = new Map[2];    static String q = "BESIGOM";    static int cnt = -1, ans = 0;    static int[] num = new int[10];    public static void bfs()    {        if(cnt == 6)        {            if((num[0] + num[3]) * (num[4] + num[5] + num[1] + num[2]) * num[6] % 2 == 0)            {                int M = m[num[6]].getOrDefault("M", 0);                int O = m[num[5]].getOrDefault("O", 0);                int G = m[num[4]].getOrDefault("G", 0);                int I = m[num[3]].getOrDefault("I", 0);                int S = m[num[2]].getOrDefault("S", 0);                int E = m[num[1]].getOrDefault("E", 0);                int B = m[num[0]].getOrDefault("B", 0);                int sum = M * O * G * I * S * E * B;                ans += sum;            }//            for(int i = 0; i &lt; 7; i ++)//                System.out.print(num[i]);//            System.out.println();            return;        }        cnt ++;        for(int i = 0; i &lt;= 1; i ++)        {            num[cnt] = i;            bfs();        }        cnt --;        return;    }    public static void main(String[] args) {        Scanner inScanner = new Scanner(System.in);        n = inScanner.nextInt();        m[0] = new TreeMap&lt;String, Integer&gt;();        m[1] = new TreeMap&lt;String, Integer&gt;();        for(int i = 1; i &lt;= n; i ++)        {            String s = inScanner.next();            int v = inScanner.nextInt();            int t = Math.abs(v) % 2;            m[t].put(s, m[t].getOrDefault(s, 0) + 1);        }        inScanner.close();        bfs();        System.out.print(ans);    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>COW</title>
      <link href="2022/01/24/cow/"/>
      <url>2022/01/24/cow/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>链接：<a href="https://www.acwing.com/problem/content/1886/">1884. COW - AcWing题库</a></p><p>奶牛贝茜在她最喜欢的牧场中发现了一块石碑，上面刻有神秘的碑文。</p><p>碑文的文字似乎来自一种神秘的古代语言，可看作一个只包含 <code>C,O,W</code> 三种字符的字符串。</p><p>尽管贝茜无法解密该文字，但是她很欣赏 <code>C,O,W</code> 按顺序构成她最喜欢的单词 <code>COW</code>。</p><p>她想知道 <code>COW</code> 在碑文中一共出现了多少次。</p><p>她不介意 <code>C,O,W</code> 之间是否存在其他字符，只要这三个字符按正确的顺序出现即可。</p><p>她也不介意多个不同的 <code>COW</code> 是否共享了一些字符。</p><p>例如，<code>COW</code> 在 <code>CWOW</code> 中只出现一次，在 <code>CCOW</code> 中出现两次，在<code>CCOOWW</code> 中出现八次。</p><p>给定碑文中的文字，请帮助贝茜计算 COW 出现的次数。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-java">import java.util.*;public class Main {    static int N = 100010;    static int n;    public static void main(String[] args) {        Scanner inScanner = new Scanner(System.in);        n = inScanner.nextInt();        String s = inScanner.next();        long a = 0, b = 0, c = 0;        inScanner.close();        for(int i = 0; i &lt; n; i ++)        {            char t = s.charAt(i);            if(t == 'C')                a ++;            else if(t == 'O')                b += a;            else                c += b;        }        System.out.println(c);    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>奶牛慢跑</title>
      <link href="2022/01/24/nai-niu-man-pao/"/>
      <url>2022/01/24/nai-niu-man-pao/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>链接：<a href="https://www.acwing.com/problem/content/1906/">1904. 奶牛慢跑 - AcWing题库</a></p><p>奶牛们又出去锻炼蹄子去了！</p><p>有 <code>N</code> 头奶牛在无限长的单行道上慢跑，且跑步方向为坐标值增大的方向。</p><p>每头奶牛在跑道上开始奔跑的位置互不相同，一些奶牛的奔跑速度可能相同，也可能不同。</p><p>由于跑道是单行道，十分狭窄，奶牛们无法相互超越。</p><p>当一头速度很快的牛追上另一头牛时，她必须减速至与另一头牛速度相同以免发生碰撞，并成为同一跑步小组的一员。此时，两头牛可以视为在同一点上。</p><p>最终，再也没有奶牛会撞到（追上）其他奶牛了。</p><p>约翰想知道在这种情况下，会剩下多少个跑步小组。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-java">import java.util.*;public class Main {    static int N = 100010;    static int n;    static node[] q = new node[N];    public static void main(String[] args) {        Scanner inScanner = new Scanner(System.in);        n = inScanner.nextInt();        for(int i = 1; i &lt;= n; i ++)            q[i] = new node(inScanner.nextInt(), inScanner.nextInt());        inScanner.close();        Arrays.sort(q, 1, n + 1);        int ans = 1, pre = q[1].y;        for(int i = 2; i &lt;= n; i ++)        {            if(q[i].y &lt;= pre)            {                pre = q[i].y;                ans ++;            }        }        System.out.println(ans);    }}class node implements Comparable&lt;node&gt;{    int x;    int y;    public node(int x, int y)    {        this.x = x;        this.y = y;    }    @Override    public int compareTo(node o) {        return o.x - x;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>公平摄影</title>
      <link href="2022/01/22/gong-ping-she-ying/"/>
      <url>2022/01/22/gong-ping-she-ying/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>链接：<a href="https://www.acwing.com/problem/content/1915/">1913. 公平摄影 - AcWing题库</a></p><p>农夫约翰的 <code>N</code> 头奶牛站在一维长围栏的不同位置。</p><p>第 <code>i</code> 头牛位于位置 <code>xi</code>，其所属品种为 <code>bi</code>（根西岛牛或荷斯坦牛）。</p><p>所有奶牛的位置各不相同。</p><p>约翰想给一段连续区间内的奶牛拍摄一张照片，用来在乡村集市上展览。</p><p>但是我们希望他所有品种的奶牛都能在照片中得到公平的展示。</p><p>因此，他希望确保无论照片中出现哪些品种的奶牛，每种品种的奶牛在照片中的数量都必须相等。</p><p>例如，一张照片中只包含荷斯坦牛是可以的，包含荷斯坦牛和根西岛牛各 <code>27</code> 头也没问题，但是包含 <code>10</code> 头荷斯坦牛和 <code>9</code> 头根西岛牛则不可以。</p><p>请确定，约翰可以拍下的满足以上条件的照片的最大尺寸。</p><p>照片的尺寸是指照片中奶牛最大和最小位置之间的差。</p><p>约翰最终可能只拍下一头奶牛，这种情况下，照片尺寸为 <code>0</code>。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-java">import java.util.*;public class Main {    static int N = 100010;    static int n;    static node[] q = new node[N];    static TreeMap&lt;Integer, Integer&gt; m = new TreeMap&lt;&gt;();    public static void main(String[] args) {        Scanner inScanner = new Scanner(System.in);        n = inScanner.nextInt();        for(int i = 1; i &lt;= n; i ++)        {            int x = inScanner.nextInt();            String s;            s = inScanner.next();            if(s.equals("G"))                q[i] = new node(x, 1);            else                q[i] = new node(x, -1);        }        Arrays.sort(q, 1, n + 1);        int ans = 0, sum = 0, pre = 0;        for(int i = 1; i &lt;= n; i ++)        {            if(!m.containsKey(sum))                m.put(sum, q[i].x);            sum += q[i].y;            if(m.containsKey(sum))                ans = Math.max(ans, q[i].x - m.get(sum));            if(i == 1 || q[i].y != q[i - 1].y)                  pre = q[i].x;            ans = Math.max(ans, q[i].x - pre);        }        System.out.println(ans);    }}class node implements Comparable&lt;node&gt;{    int x;    int y;    public node(int x, int y)    {        this.x = x;        this.y = y;    }    @Override    public int compareTo(node o) {        return x - o.x;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>懒惰的牛</title>
      <link href="2022/01/22/lan-duo-de-niu/"/>
      <url>2022/01/22/lan-duo-de-niu/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>链接：<a href="https://www.acwing.com/problem/content/1924/">1922. 懒惰的牛 - AcWing题库</a></p><p>这是一个炎热的夏日。</p><p>懒洋洋的奶牛贝茜想将自己放置在田野中的某个位置，以便可以在短距离内尽可能多地吃到美味的草。</p><p>贝茜所在的田野中共有 <code>N</code> 片草地，我们可以将田野视作一个一维数轴。</p><p>第 <code>i</code> 片草地中包含 <code>gi</code> 单位的青草，位置坐标为 <code>xi</code>。</p><p>不同草地的位置不同。</p><p>贝茜想选取田野中的某个点作为她的初始位置（可能是某片草地所在的点）。</p><p>只有一片草地与她的初始位置的距离不超过 <code>K</code> 时，贝茜才能吃到那片草地上的草。</p><p>如果贝茜选择最佳初始位置，请确定她可以吃到的青草最大数量。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-java">import java.util.*;public class Main {    static int N = 1000010;    static int n, k, len = 0;    static int[] a = new int[N];    static int[] sum = new int[N];    public static void main(String[] args) {        Scanner inScanner = new Scanner(System.in);        n = inScanner.nextInt();        k = inScanner.nextInt();        for(int i = 1; i &lt;= n; i ++)        {            int g = inScanner.nextInt();            int x = inScanner.nextInt();            a[x + 1] = g;            len = Math.max(x + 1, len);        }        inScanner.close();        sum[0] = 0;        for(int i = 1; i &lt;= len; i ++)            sum[i] = sum[i - 1] + a[i];        int ans = 0;        for(int i = 1; i &lt;= len; i ++)        {            int l = Math.max(0, i - k - 1);            int r = Math.min(len, i + k);            ans = Math.max(ans, sum[r] - sum[l]);        }        System.out.println(ans);    }}/*4 34 710 152 25 1*/</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>镜子田地</title>
      <link href="2022/01/21/jing-zi-tian-di/"/>
      <url>2022/01/21/jing-zi-tian-di/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>链接：<a href="https://www.acwing.com/problem/content/1931/">1929. 镜子田地 - AcWing题库</a></p><p>农夫约翰在屋子外面放了一些旧镜子，他的奶牛们像往常一样调皮地偷走了它们！</p><p>奶牛们将镜子放置在了一个矩形田地中，该田地可被划分为 <code>N×M</code> 个方格区域。</p><p>在每个方格区域中，奶牛在其某对对角之间放置一个双面镜，因此，共有两种放法，一种为 <code>/</code> 放置（镜子连接方格左下角和右上角），另一种为 <code>\</code> 放置（镜子连接方格左上角和右下角）。</p><p>一天晚上，奶牛贝茜将激光发射器带到了该田地中。</p><p>她站在田地外面，沿着田地的行或列水平或垂直照射光束，使光束反射一定数量的镜子。</p><p>由于镜子都是沿对角线摆放，因此经反射镜反射的水平光束最终将垂直传播，反之亦然。</p><p>贝茜想知道从田地之外射入的水平或垂直光束最多可以在田地中被反射多少次。</p><p>给定镜子田地的布局，请帮助贝茜计算这个数字。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-java">import java.util.*;public class Main {    static int n, m;    static String[] s = new String[1010];    static int[] dx = {-1, 0, 1, 0};    static int[] dy = {0, -1, 0, 1};    public static int bfs(int x, int y, int d)    {        if(x &lt; 1 || x &gt; n || y &lt; 0 || y &gt;= m)            return 0;        if(s[x].charAt(y) == '/')            d ^= 3;        else            d ^= 1;        return bfs(x + dx[d], y + dy[d], d) + 1;    }    public static void main(String[] args) {        Scanner inScanner = new Scanner(System.in);        n = inScanner.nextInt();        m = inScanner.nextInt();        int ans = 0;        for(int i = 1; i &lt;= n; i ++)            s[i] = inScanner.next();        inScanner.close();        for(int i = 1; i &lt;= n; i ++)        {            ans = Math.max(ans, bfs(i, 0, 3));            ans = Math.max(ans, bfs(i, m - 1, 1));        }        for(int i = 0; i &lt; m; i ++)        {            ans = Math.max(ans, bfs(1, i, 2));            ans = Math.max(ans, bfs(n, i, 0));        }        System.out.println(ans);    }}/*3 3/\\\\\/\/*/</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>奶牛棒球</title>
      <link href="2022/01/21/nai-niu-bang-qiu/"/>
      <url>2022/01/21/nai-niu-bang-qiu/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>链接：<a href="https://www.acwing.com/problem/content/description/1947/">1945. 奶牛棒球 - AcWing题库</a></p><p>农夫约翰的 <code>N</code> 头奶牛排成一排，每头奶牛都位于数轴中的不同位置上。</p><p>它们正在练习投掷棒球。</p><p>农夫约翰观看时，观察到一组三头牛 <code>(X,Y,Z)</code> 完成了两次成功的投掷。</p><p>牛 XX 把球扔给她右边的牛 <code>Y</code>，然后牛 <code>Y</code> 把球扔给她右边的牛 <code>Z</code>。</p><p>约翰指出，第二次投掷的距离不少于第一次投掷的距离，也不超过第一次投掷的距离的两倍。</p><p>请计算共有多少组牛 <code>(X,Y,Z)</code> 可能是约翰所看到的。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-java">import java.util.*;public class Main {    static int n;    static int[] a = new int[1010];    public static void main(String[] args) {        Scanner inScanner = new Scanner(System.in);        n = inScanner.nextInt();        for(int i = 1; i &lt;= n; i ++)            a[i] = inScanner.nextInt();        int ans = 0;        inScanner.close();        Arrays.sort(a, 1, n + 1);        for(int i = 1; i + 1 &lt; n; i ++)        {            for(int j = i + 1, l = j + 1, r = j + 1; j &lt; n; j ++)            {                int t = a[j] - a[i];                while(l &lt;= n &amp;&amp; t &gt; a[l] - a[j]) l ++;                while(r &lt;= n &amp;&amp; a[r] - a[j] &lt;= 2 * t) r ++;                ans += r - l;            }        }        System.out.println(ans);    }}/*5311074*/</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闪烁</title>
      <link href="2022/01/20/shan-shuo/"/>
      <url>2022/01/20/shan-shuo/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>链接：<a href="https://www.acwing.com/problem/content/1962/">1960. 闪烁 - AcWing题库</a></p><p>农夫约翰对牛棚里昏暗的灯光感到不满，刚刚安装了一个新吊灯。</p><p>新吊灯由 <code>N</code> 个灯泡组成，这 <code>N</code> 个灯泡围成一圈，编号为 <code>0∼N−1</code>。</p><p>奶牛对这个新吊灯非常着迷，并且喜欢玩以下游戏：</p><p>对于第 <code>i</code> 个灯泡，如果在 <code>T−1</code> 时刻，它左侧的灯泡（当 <code>i&gt;0</code> 时，为第 <code>i−1</code> 个灯泡；当 <code>i=0</code> 时，为第 <code>N−1</code> 个灯泡）是开着，那么在 <code>T</code> 时刻，就切换这个灯泡的状态。</p><p>这个游戏将持续 <code>B</code> 单位时间。</p><p>给定灯泡的初始状态，请确定在 <code>B</code> 单位时间后，它们的最终状态。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-java">import java.util.*;public class Main {    static int n;    static long k;    static int[] a = new int[1000100];    public static int update(int t)    {        int sum = 0;        for(int i = 0; i &lt; n; i ++)        {            int j = (i - 1 + n) % n;            int x = t &gt;&gt; i &amp; 1;            int y = t &gt;&gt; j &amp; 1;            sum |= (x ^ y) &lt;&lt; i;        }        return sum;    }    public static void print(int t)    {        for(int i = 0; i &lt; n; i ++)            System.out.println(t &gt;&gt; i &amp; 1);        return;    }    public static void main(String[] args) {        Scanner inScanner = new Scanner(System.in);        n = inScanner.nextInt();        k = inScanner.nextLong();        int sum = 0;        for(int i = 0; i &lt; n; i ++)        {            int t = inScanner.nextInt();            sum = sum | t &lt;&lt; i;        }        inScanner.close();        Arrays.fill(a, 0);        for(int i = 1; ; i ++)        {            sum = update(sum);            if(i == k)            {                print(sum);                break;            }            else if(a[sum] == 0)            {                a[sum] = i;            }            else             {                int l = i - a[sum];                int r = (int) ((k - i) % l);                while(r-- &gt; 0)                    sum = update(sum);                print(sum);                break;            }        }    }}/*5 610000*/</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>金发姑娘和N头牛</title>
      <link href="2022/01/20/jin-fa-gu-niang-he-n-tou-niu/"/>
      <url>2022/01/20/jin-fa-gu-niang-he-n-tou-niu/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>链接：<a href="https://www.acwing.com/problem/content/description/1954/">1952. 金发姑娘和 N 头牛 - AcWing题库</a></p><p>你可能听过关于金发姑娘和三只熊的经典故事。</p><p>然而，鲜为人知的是，金发姑娘最终成了一个农民。</p><p>在她的农场中，她的牛棚里有 N 头奶牛。</p><p>不幸的是，她的奶牛对温度相当敏感。</p><p>对于奶牛 i，使其感到舒适的温度为 Ai…Bi。</p><p>如果金发姑娘将牛棚的恒温器的温度 TT 设置为 T&lt;Ai，奶牛就会觉得冷，并会产出 X 单位的牛奶。</p><p>如果她将恒温器的温度 T 设置在 Ai≤T≤Bi，奶牛就会感到舒适，并会产出 Y 单位的牛奶。</p><p>如果她将恒温器的温度 TT 设置为 T&gt;Bi，奶牛就会觉得热，并会产出 Z 单位的牛奶。</p><p>正如所期望的那样，Y 的值始终大于 X 和 Z。</p><p>给定 X,Y,Z 以及每头奶牛感到舒适的温度范围，请计算通过合理设定恒温器温度，金发姑娘可获得的最大产奶量。</p><p>恒温器温度可设置为任何整数。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-java">import java.util.*;public class Main {    static int n, x, y, z;    static TreeMap&lt;Integer, Integer&gt; m = new TreeMap&lt;Integer, Integer&gt;();    public static void main(String[] args) {        Scanner inScanner = new Scanner(System.in);        n = inScanner.nextInt();        x = inScanner.nextInt();        y = inScanner.nextInt();        z = inScanner.nextInt();        int r = 0;        for(int i = 1; i &lt;= n; i ++)        {            int ll, lr;            ll = inScanner.nextInt();            lr = inScanner.nextInt();            r = Math.max(r, lr + 1);            m.put(0, m.getOrDefault(0, 0) + x);            m.put(ll, m.getOrDefault(ll, 0) + y - x);            m.put(lr + 1, m.getOrDefault(lr + 1, 0) - y + z);        }        inScanner.close();        long ans = 0, sum = 0;        Collection&lt;Integer&gt; value = m.values();        for(Integer i : value)        {            sum += i;            if(ans &lt; sum)                ans = sum;        }        System.out.println(ans);    }}/*4 7 9 65 83 413 207 10*/</code></pre><pre><code class="lang-java">import java.util.*;public class Main {    static int n, x, y, z;    static int[] l = new int[20010];    static int[] r = new int[20010];    static int[] b = new int[40010];    static Vector&lt;Integer&gt; v = new Vector&lt;&gt;();    public static int find(int t)    {        int l = 0, r = v.size() - 1;        while(l &lt; r)        {            int mid = l + r &gt;&gt; 1;            if(t &gt; v.get(mid))                l = mid + 1;            else                r = mid;        }        return r;    }    public static void main(String[] args) {        Scanner inScanner = new Scanner(System.in);        n = inScanner.nextInt();        x = inScanner.nextInt();        y = inScanner.nextInt();        z = inScanner.nextInt();        for(int i = 1; i &lt;= n; i ++)        {            l[i] = inScanner.nextInt();            r[i] = inScanner.nextInt();            if(!v.contains(l[i]))                v.add(l[i]);            if(!v.contains(r[i]))                v.add(r[i]);        }        v.add(Integer.MIN_VALUE);        v.add(Integer.MAX_VALUE);        Collections.sort(v);        inScanner.close();        int ll = v.size() - 1;        for(int i = 1; i &lt;= n; i ++)        {            int L = find(l[i]), R = find(r[i]);            b[0] += x;            b[L] += y -x;            b[R + 1] += z - y;            b[ll] -= z;        }        long ans = 0, sum = 0;        for(int i = 0; i &lt;= ll; i ++)        {            sum += b[i];            if(sum &gt; ans)                ans = sum;        }        System.out.println(ans);    }}/*4 7 9 65 83 413 207 10*/</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>品种邻近</title>
      <link href="2022/01/19/pin-chong-lin-jin/"/>
      <url>2022/01/19/pin-chong-lin-jin/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>链接：<a href="https://www.acwing.com/problem/content/1971/">1969. 品种邻近 - AcWing题库</a></p><p>农夫约翰的 N 头奶牛排成一排，每头奶牛都用其品种 ID 进行描述。</p><p>如果两头相同品种的牛靠得太近，它们就会吵架。</p><p>具体的说，如果同一品种的两头奶牛在队列中的位置相差不超过 K，我们就称这是一对拥挤的牛。</p><p>请计算品种 ID 最大的拥挤奶牛对的品种 ID。</p><h5 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含两个整数 N 和 K。</p><p>接下来 N 行，每行包含一个整数表示队列中一头奶牛的品种 ID。</p><h5 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h5><p>输出品种 ID 最大的拥挤奶牛对的品种 ID。</p><p>如果不存在拥挤奶牛队，则输出 −1。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-java">import java.util.*;public class Main {    public static void main(String[] args) {        Scanner inScanner = new Scanner(System.in);        int ans = -1;        int n, k;        int[] a = new int[1000100];        n = inScanner.nextInt();        k = inScanner.nextInt();        Arrays.fill(a, 0);        for(int i = 1; i &lt;= n; i ++)        {            int b = inScanner.nextInt();            if(a[b] != 0 &amp;&amp; i - a[b] &lt;= k)                ans = Math.max(b, ans);            a[b] = i;        }        inScanner.close();        System.out.println(ans);    }}/*6 3734234*/</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>奶牛过马路</title>
      <link href="2022/01/19/nai-niu-guo-ma-lu/"/>
      <url>2022/01/19/nai-niu-guo-ma-lu/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>链接：<a href="https://www.acwing.com/problem/content/1980/">1978. 奶牛过马路 - AcWing题库</a></p><p>每天，农夫约翰的 N 头奶牛都会穿过农场中间的马路。</p><p>考虑约翰的农场在二维平面的地图，马路沿水平方向延伸，马路的一侧由直线 y=0 描述，另一侧由直线 y=1 描述。</p><p>奶牛 ii 从马路一侧的位置 (ai,0) 沿直线过马路到达另一侧的位置 (bi,1)。</p><p>所有 ai 互不相同，所有 bi 互不相同。</p><p>尽管他的奶牛们行动敏捷，他还是担心行动路径交叉的两头奶牛在过马路时发生碰撞。</p><p>约翰认为，如果一头奶牛的行动路径没有跟其他任何奶牛的行动路径相交，则该奶牛是安全的。</p><p>请帮助约翰计算安全奶牛的数量。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-java">import java.util.*;public class Main {    static class node implements Comparable&lt;node&gt; {        int x, y;        @Override        public int compareTo(node o) {            return x - o.x;        }    }    public static void main(String[] args) {        Scanner inScanner = new Scanner(System.in);        int n;        int[] suma = new int[100010];        int[] sumb = new int[100010];        node[] a = new node[100010];        int ans = 0;        n = inScanner.nextInt();        for(int i = 1; i &lt;= n; i ++)        {            a[i] = new node();            a[i].x = inScanner.nextInt();            a[i].y = inScanner.nextInt();;        }        Arrays.sort(a, 1, n + 1);        suma[0] = -1000010;        sumb[n + 1] = 1000010;        for(int i = 1; i &lt;= n; i ++)            suma[i] = Math.max(suma[i - 1], a[i].y);        for(int i = n; i &gt;= 1; i --)            sumb[i] = Math.min(sumb[i + 1], a[i].y);        for(int i = 1; i &lt;= n; i ++)        {            if(suma[i - 1] &lt; a[i].y &amp;&amp; a[i].y &lt; sumb[i + 1])                ans ++;        }        inScanner.close();        System.out.println(ans);    }}/*4-3 47 810 163 9*/</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>打乱字母</title>
      <link href="2022/01/18/da-luan-zi-mu/"/>
      <url>2022/01/18/da-luan-zi-mu/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>链接：<a href="https://www.acwing.com/problem/content/1998/">1996. 打乱字母 - AcWing题库</a></p><p>农夫约翰将按字典序排列的 NN 头奶牛的名字列表贴在了牛棚的门上。</p><p>每个奶牛的名字都由一个长度介于 1 到 20 之间的由小写字母构成的唯一字符串表示。</p><p>麻烦制造者贝茜将列表中的奶牛名字重新排序打乱了列表。</p><p>此外，她还对每头奶牛的名字中的字母顺序进行了重新排列（也可能保持不变）。</p><p>给定修改过后的列表，请帮助约翰确定列表中的每个名字可能出现在原始列表中的最低和最高位置。</p><h5 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含整数 N。</p><p>接下来 N 行，按照修改过后列表的顺序，给出了修改过后的奶牛的名字。</p><h5 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h5><p>共 N 行，第 i 行输出给定的第 i 个字符串在原始列表中可能的最低和最高位置。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-java">import java.util.*;public class Main {    public static void main(String[] args) {        Scanner in = new Scanner(System.in);        int n;        n = in.nextInt();        String[] s = new String[50010];        String[] a = new String[50010];        String[] b = new String[50010];        for(int i = 1; i &lt;= n; i ++)        {            s[i] = in.next();            char[] q = s[i].toCharArray();            Arrays.sort(q);            a[i] = String.valueOf(q);            StringBuilder t = new StringBuilder(a[i]).reverse();            b[i] = String.valueOf(t);        }        in.close();        Arrays.sort(a, 1, n + 1);        Arrays.sort(b, 1, n + 1);        for(int i = 1; i &lt;= n; i ++)        {            char[] tt = s[i].toCharArray();            Arrays.sort(tt);            String t = String.valueOf(tt);            int l = 1, r = n;            while(l &lt; r)            {                int mid = (l + r) &gt;&gt; 1;                if(b[mid].compareTo(t) &gt;= 0)                    r = mid;                else                    l = mid + 1;            }            System.out.print(l + " ");            t = String.valueOf(new StringBuilder(t).reverse());            l = 1;            r = n + 1;            while(l &lt; r)            {                int mid = (l + r) &gt;&gt; 1;                if(a[mid].compareTo(t) &gt; 0)                    r = mid;                else                    l = mid + 1;            }            System.out.println(l - 1);        }    }}/*4essiebaxzyelsie */</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>马蹄铁</title>
      <link href="2022/01/18/ma-ti-tie/"/>
      <url>2022/01/18/ma-ti-tie/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>链接：<a href="https://www.acwing.com/problem/content/2007/">2005. 马蹄铁 - AcWing题库</a></p><p>尽管奶牛贝茜发现每个平衡括号字符串都很美观，但她特别喜欢被她称为“完全”平衡的括号字符串——一个由 <code>(</code> 构成的字符串后接一个长度相同的 <code>)</code> 构成的字符串。</p><p>例如：</p><pre><code>(((())))</code></pre><p>有一天，当贝茜穿过牛棚时，她发现地面上有一个 N×N 的马蹄铁矩阵。每个马蹄铁的方向都看上去像 <code>(</code> 或 <code>)</code>。</p><p>从矩阵的左上角开始，贝茜希望四处走动以拾起马蹄铁，使得她捡起的马蹄铁按顺序构成的括号字符串是完全平衡的。</p><p>请计算她能得到的最长完全平衡括号字符串的长度。</p><p>每一步中，贝茜可以沿上下左右四个方向移动。</p><p>她只能移动到包含马蹄铁的方格区域内，当她进入该区域时就会拿起那里的马蹄铁，并无法再次回到该位置（因为该位置没有马蹄铁了）。</p><p>她首先拿起的是左上角的马蹄铁。</p><p>由于她拿起的马蹄铁要形成一个完全平衡的字符串，因此她可能无法将所有马蹄铁都拿起来。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-java">import java.util.*;public class Main {    static int n;    static char[][] s = new char[10][10];    static int ans = 0;    static int[] xx = {0, 0, 1, -1};    static int[] yy = {1, -1, 0, 0};    static boolean[][] f = new boolean[10][10];    public static void bfs(int x, int y, int l, int r)    {        f[x][y] = true;        if(l == r)        {            ans = Math.max(ans, l + r);            f[x][y] = false;            return;        }        for(int i = 0; i &lt; 4; i ++)        {            int x1 = x + xx[i], y1 = y + yy[i];            if(0 &lt; x1 &amp;&amp; x1 &lt;= n &amp;&amp; 0 &lt; y1 &amp;&amp; y1 &lt;= n &amp;&amp; !f[x1][y1])            {                if(s[x][y] == ')' &amp;&amp; s[x1][y1] == '(')                    continue;                if(s[x1][y1] == ')')                    bfs(x1, y1, l, r + 1);                else                    bfs(x1, y1, l + 1, r);            }        }        f[x][y] = false;    }    public static void main(String[] args) {        Scanner inScanner = new Scanner(System.in);        n = inScanner.nextInt();        for(int i = 1; i &lt;= n; i ++)        {            String ss;            ss = inScanner.next();            for(int j = 0; j &lt; n; j ++)            {                s[i][j + 1] = ss.charAt(j);            }        }        inScanner.close();        if(s[1][1] == '(')            bfs(1, 1, 1, 0);        System.out.println(ans);    }}/*4(())()(((()())))*/</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贝茜放慢脚步</title>
      <link href="2022/01/18/bei-qian-fang-man-jiao-bu/"/>
      <url>2022/01/18/bei-qian-fang-man-jiao-bu/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>链接：<a href="https://www.acwing.com/problem/content/1936/">1934. 贝茜放慢脚步 - AcWing题库</a></p><p>奶牛贝茜正在参加冬季哞林匹克运动会的越野滑雪比赛。</p><p>她以每秒 1 米的速度出发。</p><p>但是，随着时间的推移，她变得越来越疲倦，她开始放慢脚步。</p><p>每次放慢脚步，贝茜的速度都会降低：减速一次后，她以每秒 1/2 米的速度移动，减速两次后，则以每秒 1/3 米的速度移动，依此类推。</p><p>你将被告知何时何地贝茜会减速。</p><p>当减速信息格式为：</p><pre><code>T 17</code></pre><p>意味着，贝茜在某个时间点减速，本例表示比赛开始第 17 秒贝茜减速。</p><p>当减速信息格式为：</p><pre><code>D 10</code></pre><p>意味着，贝茜在某个地点减速，本例表示在行进 10 米处减速。</p><p>给定 N 个减速信息，请计算贝茜滑完一千米需要多少秒。</p><p>将你的答案四舍五入到最接近的整数（ 0.5 向上舍入为 1）。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-java">import java.util.*;public class Main {    static int n;    static PriorityQueue&lt;Integer&gt; T = new PriorityQueue&lt;&gt;();    static PriorityQueue&lt;Integer&gt; D = new PriorityQueue&lt;&gt;();    public static void main(String[] args) {        Scanner inScanner = new Scanner(System.in);        n = inScanner.nextInt();        while(n -- &gt; 0)        {            if("T".equals(inScanner.next()))                T.offer(inScanner.nextInt());            else                D.offer(inScanner.nextInt());        }        double v = 1, time = 0, dis = 0;        while(!T.isEmpty() || !D.isEmpty())        {            if(T.isEmpty() || (!D.isEmpty() &amp;&amp; time + (D.peek() - dis) * v &lt; T.peek()))            {                time += (D.peek() - dis) * v;                dis = D.poll();            }            else            {                dis += (T.peek() - time) / v;                time = T.poll();            }            v ++;        }        int ans = (int)(time + (1000 - dis) * v + 0.5);        System.out.println(ans);        inScanner.close();    }}/*2T 30D 10*/</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>岛</title>
      <link href="2022/01/18/dao/"/>
      <url>2022/01/18/dao/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>链接：<a href="https://www.acwing.com/problem/content/2016/">2014. 岛 - AcWing题库</a></p><p>每当下雨时，农夫约翰的田地总是被洪水淹没。</p><p>由于田地不是完全水平的，所以一些地方充满水后，留下了许多被水隔开的“岛”。</p><p>约翰的田地被描述为由 N 个连续高度值 H1,…,HN 指定的一维场景。</p><p>假设该场景被无限高的围墙包围着，请考虑暴雨期间发生的情况：</p><p>最低处首先被水覆盖，形成一些不连贯的岛，随着水位的不断上升，这些岛最终都会被覆盖。</p><p>一旦水位等于一块田地的高度，那块田地就被认为位于水下。</p><p><img src="https://cdn.acwing.com/media/article/image/2020/06/24/19_8c986a0cb5-fig_islands.png" alt="fig_islands.png"></p><p>上图显示了一个示例：在左图中，我们只加入了刚好超过 1 单位的水，此时剩下 4 个岛（最大岛屿剩余数量），而在右图中，我们共加入了 7 单位的水，此时仅剩下 22个岛。</p><p>请计算，暴风雨期间我们能在某个时间点看到的最大岛屿数量。</p><p>水会一直上升到所有田地都在水下。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-java">import java.util.*;class node implements Comparable&lt;node&gt;{    int h, poit;    public node(int h, int poit)    {        this.h = h;        this.poit = poit;    }    @Override    public int compareTo(node o) {        return h - o.h;    }}public class Main {    static int n = 0;    static int[] a = new int[100010];    static node[] v = new node[100100];    public static void main(String[] args) {        Scanner inScanner = new Scanner(System.in);        int nn, cnt = 0;        nn = inScanner.nextInt();        for(int i = 1; i &lt;= nn; i ++)        {            int b;            b = inScanner.nextInt();            if(b != a[n])            {                a[++ n] = b;                v[cnt ++] = new node(a[n], n);            }        }        a[n + 1] = 0;        inScanner.close();        Arrays.sort(v, 0, cnt);;        int res = 1, ans = 0;        v[cnt] = new node(0, 0);        for(int i = 0; i &lt; cnt; i ++)        {            int j = v[i].poit;            if(a[j - 1] &gt; a[j] &amp;&amp; a[j] &lt; a[j + 1])                res ++;            else if(a[j - 1] &lt; a[j] &amp;&amp; a[j] &gt; a[j + 1])                res --;            if(v[i].h != v[i + 1].h)                ans = Math.max(ans, res);        }        System.out.println(ans);    }}/*835231423*/</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拖拉机</title>
      <link href="2022/01/17/tuo-la-ji/"/>
      <url>2022/01/17/tuo-la-ji/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>题目链接：<a href="https://www.acwing.com/problem/content/2021/">2019. 拖拉机 - AcWing题库</a></p><p>干了一整天的活，农夫约翰完全忘记了他把拖拉机落在田地中央了。</p><p>他的奶牛非常调皮，决定对约翰来场恶作剧。</p><p>她们在田地的不同地方放了 N 捆干草，这样一来，约翰想要开走拖拉机就必须先移除一些干草捆。</p><p>拖拉机的位置以及 N 捆干草的位置都是二维平面上的整数坐标点。</p><p>拖拉机的初始位置上没有干草捆。</p><p>当约翰驾驶拖拉机时，他只能沿平行于坐标轴的方向（北，南，东和西）移动拖拉机，并且拖拉机必须每次移动整数距离。</p><p>例如，驾驶拖拉机先向北移动 2 单位长度，然后向东移动 3 单位长度。</p><p>拖拉机无法移动到干草捆占据的位置。</p><p>请帮助约翰确定他需要移除的干草捆的最小数量，以便他能够将拖拉机开到二维平面的原点。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-java">import java.util.Arrays;import java.util.PriorityQueue;import java.util.Queue;import java.util.Scanner;class node implements Comparable&lt;node&gt;{    int x, y, dist;    public node(int x, int y, int dist) {        this.x = x;        this.y = y;        this.dist = dist;    }    @Override    public int compareTo(node o) {        return this.dist - o.dist;    }}public class Main {    static int n, sx, sy;    static int[][] dis = new int[2010][2010];    static boolean[][] f = new boolean[2010][2010];    static boolean[][] g = new boolean[2010][2010];    static int[] xx = {0, 0, 1, -1};    static int[] yy = {1, -1, 0, 0};    public static int dijkstra(node root)    {        Queue&lt;node&gt; q = new PriorityQueue&lt;node&gt;();        q.add(root);        while(!q.isEmpty())        {            node top = q.poll();            if(top.x == 0 &amp;&amp; top.y == 0)                break;            if(f[top.x][top.y])                continue;            f[top.x][top.y] = true;            for(int i = 0; i &lt; 4; i ++)            {                int tx = top.x + xx[i];                int ty = top.y + yy[i];                if(0 &lt;= tx &amp;&amp; tx &lt; 2000 &amp;&amp; 0 &lt;= ty &amp;&amp; ty &lt; 2000)                {                    int w = 0;                    if(g[tx][ty])                         w = 1;                    if(top.dist + w &lt; dis[tx][ty])                    {                        dis[tx][ty] = top.dist + w;                        if(!f[tx][ty])                            q.add(new node(tx, ty, dis[tx][ty]));                    }                }            }        }        return dis[0][0];    }    public static void main(String[] args) {        Scanner inScanner = new Scanner(System.in);        for(int i = 0; i &lt; dis.length; i ++)            Arrays.fill(dis[i], Integer.MAX_VALUE);        n = inScanner.nextInt();        sx = inScanner.nextInt();        sy = inScanner.nextInt();        dis[sx][sy] = 0;        for(int i = 1; i &lt;= n; i ++)        {            int a, b;            a = inScanner.nextInt();            b = inScanner.nextInt();            g[a][b] = true;        }        inScanner.close();        int ans = dijkstra(new node(sx, sy, 0));        System.out.println(ans);    }}/*7 6 36 25 24 32 17 35 46 4*/</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>奶牛选美</title>
      <link href="2022/01/16/nai-niu-xuan-mei/"/>
      <url>2022/01/16/nai-niu-xuan-mei/</url>
      
        <content type="html"><![CDATA[<h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://www.acwing.com/problem/content/2062/">2060. 奶牛选美 - AcWing题库</a></p><p>听说最近两斑点的奶牛最受欢迎，约翰立即购进了一批两斑点牛。</p><p>不幸的是，时尚潮流往往变化很快，当前最受欢迎的牛变成了一斑点牛。</p><p>约翰希望通过给每头奶牛涂色，使得它们身上的两个斑点能够合为一个斑点，让它们能够更加时尚。</p><p>牛皮可用一个 N×M 的字符矩阵来表示，如下所示：</p><pre><code>..................XXXX....XXX......XXXX....XX....XXXX......XXX..........XXXXX............XXX....</code></pre><p>其中，X 表示斑点部分。</p><p>如果两个 X 在垂直或水平方向上相邻（对角相邻不算在内），则它们属于同一个斑点，由此看出上图中恰好有两个斑点。</p><p>约翰牛群里<strong>所有的牛都有两个斑点</strong>。</p><p>约翰希望通过使用油漆给奶牛尽可能少的区域内涂色，将两个斑点合为一个。</p><p>在上面的例子中，他只需要给三个 .. 区域内涂色即可（新涂色区域用 ∗ 表示）：</p><pre><code>..................XXXX....XXX......XXXX*...XX....XXXX..**..XXX..........XXXXX............XXX....</code></pre><p>请帮助约翰确定，为了使两个斑点合为一个，他需要涂色区域的最少数量。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-java">import java.util.*;public class Main {    static int n, m;    static int N = 100;    static int[] xx = {1,0,-1,0};    static int[] yy = {0,1,0,-1};    static char[][] s = new char[N][N];    static boolean[][] f = new boolean[N][N];    static List&lt;node&gt;[] q = new ArrayList[2];    static class node{        int x, y;        public node(int x, int y) {            this.x = x;            this.y = y;        }    }    public static void bfs(int x, int y, int cnt) {        f[x][y] = true;        q[cnt].add(new node(x, y));        for(int i = 0; i &lt; 4; i ++)        {            int x1 = x + xx[i];            int y1 = y + yy[i];            if(0 &lt;= x1 &amp;&amp; x1 &lt; n &amp;&amp; 0 &lt;= y1 &amp;&amp; y1 &lt; m &amp;&amp; !f[x1][y1] &amp;&amp; s[x1][y1] == 'X')                bfs(x1, y1, cnt);        }    }    public static void main(String[] args) {        Scanner inScanner = new Scanner(System.in);        n = inScanner.nextInt();        m = inScanner.nextInt();        for(int i = 0; i &lt; q.length; i ++)            q[i] = new ArrayList&lt;&gt;();        for(int i = 0; i &lt; n; i ++)        {            String ss;            ss = inScanner.next();            for(int j = 0; j &lt; m; j ++)                s[i][j] = ss.charAt(j);        }        int cnt = 0;        for(int i = 0; i &lt; n; i ++)        {            for(int j = 0; j &lt; m; j ++)            {                if(!f[i][j] &amp;&amp; s[i][j] == 'X')                {                    bfs(i, j, cnt);                    cnt ++;                }            }        }        inScanner.close();        int ans = 100000;        for(node a : q[0])            for(node b : q[1])            {                int t = Math.abs(a.x - b.x) + Math.abs(a.y - b.y) - 1;                ans = Math.min(ans, t);            }        System.out.println(ans);    }}/* * 6 16..................XXXX....XXX......XXXX....XX....XXXX......XXX..........XXXXX............XXX.... **/</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>粉刷栅栏</title>
      <link href="2022/01/15/fen-shua-zha-lan/"/>
      <url>2022/01/15/fen-shua-zha-lan/</url>
      
        <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>题目链接：<a href="https://www.acwing.com/problem/content/1989/">1987. 粉刷栅栏 - AcWing题库</a></p><p>农夫约翰发明了一种绝妙的方法来粉刷牛棚旁边的长栅栏（把栅栏想象成一维的数轴）。</p><p>他只需要在他最喜欢的奶牛贝茜身上挂一个刷子，然后在一旁悠闲的喝凉水就行了。</p><p>贝茜沿着栅栏来回走动时，会将她走过的栅栏部分涂上油漆。</p><p>贝茜从栅栏上的位置 0 处开始，共进行 N 次移动。</p><p>移动可能形如 <code>10 L</code>，表示向左移动 10 单位距离，也可能形如 <code>15 R</code>，表示向右移动 15 单位距离。</p><p>给定贝茜的 N 次移动列表，约翰想知道至少被涂抹了 2 层油漆的区域的总长度。</p><p>整个行进过程中，贝茜距离出发地的距离不会超过 $10^9$。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-java">import java.util.*;public class Main{    public static void main(String[] args) {        Scanner in = new Scanner(System.in);        int n;        Map&lt;Integer,Integer&gt; m = new TreeMap&lt;&gt;( (a,b) -&gt; a-b );        n = in.nextInt();        int idx = 0;        for(int i = 1; i &lt;= n; i ++)        {            int x;            String s;            x = in.nextInt();            s = in.next();            if(s.equals("L"))            {                m.put(idx, m.getOrDefault(idx, 0) - 1);                idx -= x;                m.put(idx, m.getOrDefault(idx, 0) + 1);            }            else            {                m.put(idx, m.getOrDefault(idx, 0) + 1);                idx += x;                m.put(idx, m.getOrDefault(idx, 0) - 1);            }        }        long sum = 0, ans = 0;        int p = 0;        for(int i : m.keySet())        {            if(sum &lt;= 1 &amp;&amp; sum + m.get(i) &gt; 1)                p = i;            else if(sum &gt; 1 &amp;&amp; sum + m.get(i) &lt;= 1)                ans += i - p;            sum += m.get(i);        }        System.out.println(ans);        in.close();    }}/*62 R6 L1 R8 L1 R2 R*/</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笨拙的手指</title>
      <link href="2022/01/13/ben-zhuo-de-shou-zhi/"/>
      <url>2022/01/13/ben-zhuo-de-shou-zhi/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>奶牛贝茜正在学习如何在不同进制之间转换数字。</p><p>但是她总是犯错误，因为她无法轻易的用两个前蹄握住笔。</p><p>每当贝茜将数字转换为一个新的进制并写下结果时，她总是将其中的某一位数字写错。</p><p>例如，如果她将数字 $14$ 转换为二进制数，那么正确的结果应为$ 11101110$，但她可能会写下 $01100110 或 11111111$。</p><p>贝茜不会额外添加或删除数字，但是可能会由于写错数字的原因，写下包含前导 00 的数字。</p><p>给定贝茜将数字 $N$ 转换为二进制数字以及三进制数字的结果，请确定 $N$ 的正确初始值（十进制表示）。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>进行枚举，枚举每位出错，然后对比出错后两者是否相等。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-java">import java.util.Arrays;import java.util.HashMap;import java.util.Scanner;import java.lang.Math;public class Main{    public static int work(String a, String b)    {        int la = a.length();        int lb = b.length();        char[] sa = a.toCharArray();        char[] sb = b.toCharArray();        for(int i = 0; i &lt; la; i ++)        {            char qa = sa[i];            if(sa[i] == '0')                sa[i] = '1';            else                sa[i] = '0';            String a1 = new String(sa);            int na = Integer.parseInt(a1, 2);            for(int j = 0; j &lt; lb; j ++)            {                char qb = sb[j];                for(char k = '0'; k &lt;= '2'; k ++)                {                        if(k != qb)                    {                        sb[j] = k;                        String b1 = new String(sb);                        int nb = Integer.parseInt(b1, 3);                        if(na == nb)                            return na;                    }                }                sb[j] = qb;            }            sa[i] = qa;        }        return 0;    }    public static void main(String[] args) {        Scanner in = new Scanner(System.in);        String s,s1;        s = in.next();        s1 = in.next();        int ans = work(s, s1);        System.out.printf("%d\n", ans);    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu搭建docker以及wordpress</title>
      <link href="2021/11/06/ubuntu-da-jian-docker-yi-ji-wordpress/"/>
      <url>2021/11/06/ubuntu-da-jian-docker-yi-ji-wordpress/</url>
      
        <content type="html"><![CDATA[<h3 id="安装docker以及搭建wordpress的过程。"><a href="#安装docker以及搭建wordpress的过程。" class="headerlink" title="安装docker以及搭建wordpress的过程。"></a>安装docker以及搭建wordpress的过程。</h3><ol><li><p>安装docker，根据官方文档的安装过程进行一步步安装。</p><p>安装文档地址：<a href="https://docs.docker.com/engine/install/ubuntu/">https://docs.docker.com/engine/install/ubuntu/</a></p></li><li><p>启动docker服务：<code>sudo service docker start</code></p></li><li><p>docker安装wordpress：</p><pre><code class="lang-do">sudo docker pull wordpress：latest</code></pre></li><li><p>docker安装mysql</p><pre><code class="lang-do">sudo docker pull mysql</code></pre><p>配置mysql：</p><pre><code class="lang-doc">sudo docker run -d -p 3306:3306 -v /var/lib/mysql:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql mysql</code></pre><p>-d： 后台运行，我们数据库肯定上需要一直在跑的嘛。<br>-p： 上映射端口，mysql容器相当于一台虚拟机，是不能直接从外网访问的，需要通过主机去访问，前面的上主机端口 : 后面上容器端口，现在上将3306映射到3306上，这样访问公网的3306就是容器的端口了，但一般可以改其他端口，不安全。<br>-v： 是相当于文件夹重定向吧，将主机的一个目录和容器目录同步，这样会方便修改日期的文件及配置。<br>-e： 环境变量，设置数据库密码，还有–name 容器的名称。</p><p><code>mysql  -u root -p</code>进入mysql</p></li><li><p>运行wordpress</p><pre><code class="lang-javascript">//有volume的sudo docker run --name wordpress -v /var/www/html:/var/www/html --link mysql:mysql -p 5001:80 -d wordpress//没有数据卷的sudo docker run --name wordpress --link mysql:mysql -p 5001:80 -d wordpress</code></pre></li><li><p>输入服务器ip就进行构建。</p><p>桥接模式直接输入虚拟机的ip，我的是<code>192.168.43.100</code></p></li><li><p>选择安装的语言。<img src="/2021/11/06/ubuntu-da-jian-docker-yi-ji-wordpress/image-20211105193948170.png" alt=""></p></li><li><p>设置有关数据库的信息。<img src="/2021/11/06/ubuntu-da-jian-docker-yi-ji-wordpress/image-20211105194206220.png" alt=""></p></li><li><p>需要注意的是：<font color="red">mysql要存在wordpress数据库</font></p><font color="red">如果虚拟机的网络配置为NAT模式，数据库主机为localhost</font><p><img src="/2021/11/06/ubuntu-da-jian-docker-yi-ji-wordpress/image-20211105194832393.png" alt=""></p></li><li><p>然后进行安装。</p><p><img src="/2021/11/06/ubuntu-da-jian-docker-yi-ji-wordpress/image-20211105195042500.png" alt=""></p></li><li><p>安装成功</p><p><img src="/2021/11/06/ubuntu-da-jian-docker-yi-ji-wordpress/image-20211105195122276.png" alt=""></p></li><li><p>登录用户。</p><p><img src="/2021/11/06/ubuntu-da-jian-docker-yi-ji-wordpress/image-20211105195136423.png" alt=""></p></li><li><p>然后就完成了wordpress的安装。</p><p><img src="/2021/11/06/ubuntu-da-jian-docker-yi-ji-wordpress/image-20211105195528701.png" alt=""></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 搭建教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P3599 Koishi Loves Construction</title>
      <link href="2021/03/11/p3599-koishi-loves-construction/"/>
      <url>2021/03/11/p3599-koishi-loves-construction/</url>
      
        <content type="html"><![CDATA[<p>题目链接：<a href="https://www.luogu.com.cn/problem/P3599">https://www.luogu.com.cn/problem/P3599</a></p><p>题解：</p><p><img src="/2021/03/11/p3599-koishi-loves-construction/1.png" alt=""></p><p>代码：</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;sstream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;map&gt;#include&lt;set&gt;#define inf 0x3f3f3f3f#include&lt;cstring&gt;#include&lt;cstdio&gt;#define N 10000#define  ll long long#define PI acos(-1)#define mset(s, _) memset(s, _, sizeof(s))//#define lousing namespace std;void coutx(double q, int x){    //cout.setf(ios::fixed);    //cout.unsetf(ios::fixed);    cout &lt;&lt; fixed &lt;&lt; setprecision(x) &lt;&lt; q &lt;&lt; endl;    return ;}inline ll ksc(ll x, ll y, ll mod)//快速乘{    return ( x * y - (ll) ( (long double) x / mod*y )*mod + mod ) % mod;}ll gcd(ll a,ll b){    return b==0?a:gcd(b,a%b);}ll lcm(ll a,ll b){    return a/gcd(a,b)*b;}int X, T;int n;bool isprime(int k){    for(int i = 2; i &lt;= sqrt(k); i ++)    {        if(k % i == 0)            return false;    }    return true;}ll inv[100010];void work(){    if(n != 4)    {        cout &lt;&lt; 2 &lt;&lt; ' ' &lt;&lt; 1 &lt;&lt; ' ';        inv[1] = 1;        for(int i = 2; i &lt; n; i ++)        {            inv[i] = (ll)((n - n / i) * inv[n % i]) % n;            cout &lt;&lt; (i * inv[i - 1] + n) % n &lt;&lt; ' ';        }        cout &lt;&lt; n &lt;&lt; endl;    }    if(n == 4)        cout &lt;&lt; "2 1 3 2 4" &lt;&lt; endl;    return;}int main(){    #ifdef lo     freopen("data.in","r",stdin);     freopen("data.out","w",stdout);    #endif    srand((unsigned int)time(0));    ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin &gt;&gt; X &gt;&gt; T;    if(X == 1)    {        while(T --)        {            cin &gt;&gt; n;            int a = n;            int b = 1;            if(n == 1)                cout &lt;&lt; "2 1" &lt;&lt; endl;            else if(n % 2)                cout &lt;&lt; 0 &lt;&lt; endl;            else            {                cout &lt;&lt; 2;                while(b &lt;= n - 1)                {                    cout &lt;&lt; ' ' &lt;&lt; a &lt;&lt; ' ' &lt;&lt; b;                    a -= 2;                    b += 2;                }                cout &lt;&lt; endl;            }         }     }    else    {            while(T --)        {            cin &gt;&gt; n;            if(n == 4 || isprime(n))                work();            else                cout &lt;&lt; 0 &lt;&lt; endl;        }    }    return 0; }</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>（一）一群小青蛙呱蹦呱蹦呱</title>
      <link href="2021/03/01/yi-qun-xiao-qing-wa-gu-beng-gu-beng-gu/"/>
      <url>2021/03/01/yi-qun-xiao-qing-wa-gu-beng-gu-beng-gu/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>链接：<a href="https://ac.nowcoder.com/acm/contest/9981/J">https://ac.nowcoder.com/acm/contest/9981/J</a><br>来源：牛客网</p><p>有n个格子，每个格子里有一个数，1,2,3,4…n   </p><p>   牛牛放出<strong>无穷</strong>只青蛙。   </p><p>   第一只青蛙的路线是：1-&gt;2-&gt;4-&gt;8-&gt;16-&gt;….   </p><p>   第二只青蛙的路线是：1-&gt;3-&gt;9-&gt;27-&gt;81-&gt;….   </p><p>   第三只青蛙的路线是：1-&gt;5-&gt;25-&gt;125….   </p><p>   第四只青蛙的路线是：1-&gt;7-&gt;49……..   </p><p>   。。。。。。   </p><p>   用数学语言描述，第 i只青蛙的路线是首项为1，公比为p(i)的等比数列，其中p(i)代表第个素数。   </p><p>   当青蛙跳到一个格子上，如果这个格子上面有一个数，青蛙就会把这个数吃掉。   </p><p>   牛牛想知道，所有<strong>没有被</strong>吃掉的数的lcm（最小公倍数 ，Least common multiple）是多少？   </p><p>   由于这个lcm可能非常大，请输出它对10<sup>9</sup> + 7取模的值。</p><h4 id="输入描述："><a href="#输入描述：" class="headerlink" title="输入描述："></a>输入描述：</h4><p>一个整数n</p><p>1 &lt;= n &lt;= 1.6 * 10<sup>8</sup></p><h4 id="输出描述："><a href="#输出描述：" class="headerlink" title="输出描述："></a>输出描述：</h4><p>如果所有数都被吃掉了，请输出一个字符串”empty”</p><p>否则输出所有没有被吃掉的数的lcm，对模10<sup>9</sup> + 7</p><h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><p><img src="/2021/03/01/yi-qun-xiao-qing-wa-gu-beng-gu-beng-gu/silu.png" style="zoom: 67%;"></p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;sstream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;map&gt;#include&lt;set&gt;#define inf 0x3f3f3f3f#include&lt;cstring&gt;#include&lt;cstdio&gt;#define  ll long long#define PI acos(-1)#define mset(s, _) memset(s, _, sizeof(s))//#define lousing namespace std;void coutx(double q, int x){    //cout.setf(ios::fixed);    //cout.unsetf(ios::fixed);    cout &lt;&lt; fixed &lt;&lt; setprecision(x) &lt;&lt; q &lt;&lt; endl;    return ;}inline ll ksc(ll x, ll y, ll mod)//快速乘{    return ( x * y - (ll) ( (long double) x / mod*y )*mod + mod ) % mod;}ll gcd(ll a,ll b){    return b==0?a:gcd(b,a%b);}ll lcm(ll a,ll b){    return a/gcd(a,b)*b;}const int mod1 = 1e9 + 7;const int N = 8e7+7;bool isprime[N];ll vis[N];int sieve(int n)//线性筛{    int cnt = 0;    isprime[0] = isprime[1] = true;    for(int i = 2; i &lt;= n; i ++)    {        if(!isprime[i])        vis[ ++ cnt] = i;        for(int j = 1; j &lt;= cnt &amp;&amp; i * vis[j] &lt;= n; j ++)        {            isprime[i * vis[j]] = 1;            if(i % vis[j] == 0)                break;        }        }    return cnt;}int log(int n, int m){    ll res = 0;    ll t = 1;    while(t &lt;= m)    {        t *= n;        res ++;    }    return res - 1;}ll poww(ll a, ll b)//快速幂{    ll ans = 1;    while(b)    {        if(b &amp; 1)             ans = ksc(ans, a, mod1) % mod1;        a = ksc(a, a, mod1) % mod1;        a %= mod1;        b &gt;&gt;= 1;        ans %= mod1;    }    return ans % mod1; } int main(){    #ifdef lo     freopen("data.in","r",stdin);     freopen("data.out","w",stdout);    #endif    srand((unsigned int)time(0));    ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    int n, cnt;    ll ans;    cin &gt;&gt; n;    if(n &lt;= 5)    {        cout &lt;&lt; "empty";        return 0;    }    cnt = sieve(n / 2);    ans = poww(2, log(2, n / 3));    for(int i = 2; i &lt;= cnt; i ++)    {        ans = (ans % mod1) * poww(vis[i], log(vis[i], n / 2));        ans %= mod1;    }    cout &lt;&lt; ans % mod1;    return 0; }</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 编程算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
